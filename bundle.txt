# === GPT System Overview Request ===

You are a senior developer reviewing this project for a new team member.

> Note: This codebase uses the macro #define let auto&& as a syntactic shorthand
> to mimic dynamic-language style in function parameters. When you see let, 
> interpret it as uto&&.

Please do the following:

1. **Give an overview** of what this project does and its main components.
2. **Explain how each component works**, especially:
   - main.cpp
   - Core and CoreManager classes
   - Scheduler, SchedulerStrategy, and SchedulerData
   - Process and how it interacts with the Console and Instructions
   - Command system and Shell
3. **Describe how everything fits together** during execution:
   - How a process is created, assigned, executed, and logged.
   - How the scheduler ticks and how cores are managed.
4. **Highlight entry points** and flow of control.
5. **Note any potential issues or architecture strengths/weaknesses.**

Use the FILE: and PATH: headers to locate the content.

Please write in clear sections and simple language for onboarding a new developer.

--- End of prompt ---

------------------------------
 FILE:  main.cpp
 PATH:  main.cpp
------------------------------

#include "core/common/imports/_all.hpp"
#include "core/shell/Shell.hpp"


int main() {
  auto shell = Shell(); // Main shell interface
  shell.start();        // Launch shell thread
}

------------------------------
 FILE:  Command.hpp
 PATH:  core\command\Command.hpp
------------------------------

#pragma once 
#include "core/common/imports/_all.hpp"


/** @brief Represents a parsed command-line input. */
class Command {
  public:

  Command():
    name  (""s),              // The command name (e.g., "screen", "exit")
    args  (vec<str>()),       // Positional arguments for the command
    flags (map<str,str>()) {} // Map of flags and their associated values (if any)

  // ------- Member variables -------
  str name;    
  vec<str> args;    
  map<str,str> flags;   
};

------------------------------
 FILE:  CommandHandler.hpp
 PATH:  core\command\CommandHandler.hpp
------------------------------

#pragma once 
#include "core/common/imports/_all.hpp"
#include "Command.hpp"
#include "types.hpp"


/** Represents a single command entry in the interpreter. */
class Shell;
class CommandHandler {
  public:

  CommandHandler():
    name     (""s),         // Command name (e.g., "screen", "exit")
    desc     (""s),         // Description for help or documentation
    min_args (0u),          // Minimum number of required arguments
    max_args (UINT_MAX),    // Maximum number of allowed arguments
    flags    (vec<Flag>()), // Valid flags for this command
    disabled (true),        // Commands are disabled by default
    validate (nullptr),     // Optional validation hook
    execute  (nullptr) {}   // Main handler for executing the command

  // Chainable Setters
  auto set_name(const str& value) -> CommandHandler& { return name = value, *this; }
  auto set_desc(const str& value) -> CommandHandler& { return desc = value, *this; }
  auto set_min_args(uint value) -> CommandHandler& { return min_args = value, *this; }
  auto set_max_args(uint value) -> CommandHandler& { return max_args = value, *this; }
  auto set_flags(const vec<Flag>& value) -> CommandHandler& { return flags = value, *this; }
  auto set_disabled(bool value) -> CommandHandler& { return disabled = value, *this; }
  auto set_validate(func<optional<str>(Command&, Shell&)> value) -> CommandHandler& { return validate = value, *this; }
  auto set_execute(func<void(Command&, Shell&)> value) -> CommandHandler& { return execute = value, *this; }
    
  // ------- Member variables -------
  
  str name;                        
  str desc;                        
  uint min_args;                
  uint max_args;              
  vec<Flag> flags;                       
  bool disabled;
  func<optional<str>(Command&,Shell&)> validate; 
  func<void(Command&,Shell&)> execute;
};

------------------------------
 FILE:  CommandInterpreter.hpp
 PATH:  core\command\CommandInterpreter.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "CommandHandler.hpp"
#include "CommandParser.hpp"


/**
 * @class CommandInterpreter
 * @brief Responsible for parsing, validating, and executing registered commands.
 * Acts as a central dispatcher for handling parsed input lines and invoking the appropriate command logic.
 */
class Shell;  // Forward declaration
class CommandInterpreter {
  public: 

  CommandInterpreter():
    handlers (map<str,CommandHandler>()) {} // Registry of available command handlers
  
  /** @brief Returns the global singleton get of the CommandInterpreter. */
  static CommandInterpreter& get() {
    static auto inst = CommandInterpreter();
    return inst;
  }

  /** @brief Registers a command with its name and handlers. */
  void register_command(CommandHandler handler) {
    handlers[handler.name] = move(handler);
  }

  /** @brief Executes a command in the shell context. */ 
  void execute(const str& line, Shell& shell) {

    // Parse the command line into a Command (name, args, flags)
    auto command = CommandParser::parse(line);  
    if (command.name.empty()) 
      return;

    // Find command in the registry
    auto it = handlers.find(command.name);       
    if (it == handlers.end())
      return void(cout << format("[Shell] Unknown command: {}\n", command.name));

    auto& handler = it->second;

    // Check if command is disabled
    if (handler.disabled)
      return void(cout << "[Shell] This command is unavailable.\n");

    // Check for unknown/misused flags
    if (invalid_flags(command, handler))
      return void(cout << format("[Shell] Invalid or misused flag(s) for '{}'\n", command.name));

    // Check positional argument count
    if (invalid_args(command, handler))
      return void(cout << format("[Shell] Invalid number of arguments for '{}'\n", command.name));                  

    // Run optional command-specific validation logic
    if (auto msg = custom_validation(command, handler, shell))
      return void(cout << format("[Shell] {}\n", *msg));
    
    // Execute the command
    cout << '\n';
    handler.execute(command, shell);
  }

  // ------- Member variables -------
  
  map<str,CommandHandler> handlers; 

  // ------- Internal logic -------

  private:

  /** @brief Returns true if any flag is invalid or misused. */
  static auto invalid_flags(Command& command, CommandHandler& handler) -> bool {
    // If any user flag has no valid match (in name and usage), then the set of flags is invalid.
    return any_of(command.flags, [&](auto& flag) {
      return none_of(handler.flags, [&](Flag& f) {
        return f.name == flag.first && f.has_arg == !flag.second.empty();
      });
    });
  }

  /** @brief Checks if argument count is within bounds. */
  static auto invalid_args(Command& command, CommandHandler& handler) -> bool {
    auto argc = command.args.size();
    return argc < handler.min_args || argc > handler.max_args;
  }

  /** Runs the handler's custom validator and returns an optional error message. */
  static auto custom_validation(Command& command, CommandHandler& handler, Shell& shell) -> Str {
    if (!handler.validate) return nullopt;
    if (auto err = handler.validate(command, shell))
      return err->empty() ? "CommandHandler disabled or invalid." : *err;
    return nullopt;
  }
};

------------------------------
 FILE:  CommandParser.hpp
 PATH:  core\command\CommandParser.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/command/Command.hpp"


/**
 * @class Parser
 * @brief Utility class for tokenizing and parsing command lines.
 */
class CommandParser {
  public:

  /** @brief A helper that parses a handler line string into a Handler Command object. */
  static auto parse(const str& line) -> Command {
    auto tokens = tokenize(line);
    if (tokens.empty()) return {};

    auto cmd = Command();
    cmd.name = move(tokens[0]);

    for (uint i=1; i < tokens.size(); ++i) {
      str token = move(tokens[i]);
      if (token[0] != '-') {
        cmd.args.emplace_back(move(token));
        continue;
      }
      bool next_is_arg = (i+1 < tokens.size() && tokens[i+1][0] != '-');
      cmd.flags.emplace(move(token), next_is_arg ? move(tokens[++i]) : "");
    }

    return cmd;
  }

  // ------ Internal logic ------

  private:
  
  /** @brief A helper that splits a string into whitespace-separated tokens. */
  static auto tokenize(const str& line) -> vec<str> {
    if (line.empty()) return {};
    auto stream = isstream(line);
    auto tokens = vec<str>(); 

    for (str token; stream >> token; )
      tokens.emplace_back(move(token));
    return tokens;
  }
};

------------------------------
 FILE:  types.hpp
 PATH:  core\command\types.hpp
------------------------------

#pragma once 
#include "core/common/imports/_all.hpp"


/** @brief Contains the flag name and whether it requires an argument. */
struct Flag {
  str name = "";        // Flag name (e.g., "-s", "-r", "-ls")
  bool has_arg = false; // Whether the flag requires an argument
};

------------------------------
 FILE:  cls.hpp
 PATH:  core\command\handlers\cls.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_cls() -> CommandHandler {
  return CommandHandler()
    .set_name("cls")
    .set_desc("Clear screen contents.")
    .set_min_args(0)
    .set_max_args(0)
    .set_disabled(false)

    .set_execute([](Command&, Shell&) {
      system("cls");
    });
}


------------------------------
 FILE:  config.hpp
 PATH:  core\command\handlers\config.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_config() -> CommandHandler {
  return CommandHandler()
    .set_name("config")
    .set_desc("Displays the current scheduler configuration.")
    .set_min_args(0)
    .set_max_args(0)
    .set_disabled(false)

    .set_execute([](Command&, Shell& shell) {
      auto& config = shell.scheduler.data.config;
      cout << "â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Scheduler Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n";

      for (auto& [key, val]: config.all()) {
        auto display = ""s;

        if (val.type() == typeid(str))
          display = format("\"{}\"", cast<str>(val));
        else if (val.type() == typeid(uint))
          display = to_string(cast<uint>(val));
        else if (val.type() == typeid(bool))
          display = cast<bool>(val) ? "true" : "false";
        else
          display = "<unsupported>";

        cout << format("â”‚ {:<22} â”‚ {:<45} â”‚\n", key, display);
      }

      cout << "â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n";
    });
}

------------------------------
 FILE:  demo.hpp
 PATH:  core\command\handlers\demo.hpp
------------------------------

#pragma once
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_demo() -> CommandHandler {
  return CommandHandler()
    .set_name("demo")
    .set_desc("Creates and steps a demo process with random instructions.")
    .set_min_args(0)
    .set_max_args(0)
    
    .set_execute([](Command&, Shell& shell) {
      auto& storage = shell.storage;

      if (!storage.has("demo.counter")) {
        cout << "Counter created! Run demo again to increment counter.\n";
        cout << "Counter: 0\n";
        storage.set("demo.counter", 0u);
        return;
      }

      auto counter = storage.get<uint>("demo.counter") + 1;
      storage.set("demo.counter", counter);
      cout << format("Counter: {}\n", counter);
    });
}

------------------------------
 FILE:  echo.hpp
 PATH:  core\command\handlers\echo.hpp
------------------------------

#pragma once
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_echo() -> CommandHandler {
  return CommandHandler()
    .set_name("echo")
    .set_desc("Print arguments.")
    .set_min_args(1)
    .set_max_args(UINT_MAX)
    .set_flags({})
    .set_disabled(false)

    .set_execute([](Command& command, Shell&) {
      for (auto& arg: command.args)
        cout << arg << ' ';
      cout << '\n';
    });
}

------------------------------
 FILE:  exit.hpp
 PATH:  core\command\handlers\exit.hpp
------------------------------

#pragma once
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_exit() -> CommandHandler {
  return CommandHandler()
    .set_name("exit")
    .set_desc("Exit shell.")
    .set_min_args(0)
    .set_max_args(0)
    .set_flags({})
    .set_disabled(false)

    .set_execute([](Command&, Shell& shell) {
      auto& screen = shell.screen;
      if (screen.is_main())
        shell.stop();
      else
        screen.switch_to_main();
    });
}

------------------------------
 FILE:  initialize.hpp
 PATH:  core\command\handlers\initialize.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/common/constants/banner.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/shell/internal/Shell.impl.hpp"
#include "core/scheduler/types.hpp"


auto make_initialize() -> CommandHandler {
  return CommandHandler()
    .set_name("initialize")
    .set_desc("Initializes the processor configuration of the application.")
    .set_min_args(0)
    .set_max_args(0)
    .set_flags({})
    .set_disabled(false)

    .set_validate([](Command& command, Shell& shell) -> Str {
      auto config = shell.scheduler.data.config;
      
      // Check if the scheduler has already been initialized
      if (config.getb("initialized"))
        return "Already initialized.";

      // Check if the file could not be opened or is empty
      auto lines = read_lines("config.txt");
      if (lines.empty())
        return "Failed to open config.txt";

      auto& storage = shell.storage;
      storage.set("initialize.cache", move(lines));
      return nullopt;
    })

    .set_execute([](Command& command, Shell& shell) {
      auto& storage = shell.storage;
      auto& lines = storage.get<vec<str>>("initialize.cache");
      auto config = Config();

      for (auto& line: lines) {
        str key, value;
        isstream(line) >> key >> value;
        config.set(key, Config::parse(value));
      }

      config.set("initialized", true);
      shell.scheduler.set_config(move(config));

      system("cls");
      cout << format("{}\n", BANNER);
      cout << "[Shell] Scheduler config loaded.\n";
      storage.remove("initialize.cache");

      // Enable other commands
      for (auto& [name, handler]: shell.interpreter.handlers)
        handler.set_disabled(false);
    });
}

------------------------------
 FILE:  process-smi.hpp
 PATH:  core\command\handlers\process-smi.hpp
------------------------------

#pragma once
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/shell/internal/Shell.impl.hpp"
#include "core/process/Process.hpp"
#include "core/execution/Core.hpp"


auto make_process_smi() -> CommandHandler {
  return CommandHandler()
    .set_name("process-smi")
    .set_desc("Shows the current process status, logs, and info.")
    .set_min_args(0)
    .set_max_args(0)
    .set_flags({})

    .set_validate([](Command& command, Shell& shell) -> Str {
      if (shell.screen.is_main())
        return "Not in a process screen.";

      auto& scheduler = shell.scheduler;
      uint pid = shell.screen.get_id();

      if (!scheduler.data.has_process(pid))
        return format("Active process with ID \"{}\" not found.", pid);

      return nullopt;
    })

    .set_execute([](Command& command, Shell& shell) {
      auto& scheduler = shell.scheduler;
      auto& storage = shell.storage;

      uint pid = shell.screen.get_id();
      auto& process = scheduler.data.get_process(pid);
      auto& program = process.data.program;

      cout << format("Process name: {}\n", process.data.name);
      cout << format("ID: {}\n", process.data.core_id);

      cout << "Logs:\n";
      for (auto& log: process.data.logs)
        cout << format("{}\n", log);

      cout << format("Current instruction line: {}\n", program.ip);
      cout << format("Lines of code: {}\n\n", program.script.size());

      shell.storage.remove("process-smi.pid");
    });
}

------------------------------
 FILE:  report-util.hpp
 PATH:  core\command\handlers\report-util.hpp
------------------------------

#pragma once
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_report_util() -> CommandHandler {
  return CommandHandler()
    .set_name("report-util")
    .set_desc("Generates a CPU unitilization report.")
    .set_min_args(0)
    .set_max_args(0)
    .set_flags({})
    
    .set_validate([](Command& command, Shell& shell) -> Str {
      if (!shell.screen.is_main())
        return "Not in the Main Menu.";

      auto config = shell.scheduler.data.config;
      if (!config.getb("initialized"))
        return "Scheduler not initialized. Please run 'initialize' first.";

      return nullopt;
    })

    .set_execute([](Command& command, Shell& shell) {
      auto& scheduler = shell.scheduler;
      auto& data = scheduler.data;
      auto running = data.get_running_pids();
      auto& finished = data.finished_pids;

      auto log = ofstream("csopesylog.txt");
      auto separator = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";

      cout << format("\033[38;5;33m{}\033[0m", separator);
      log << separator;

      cout << "Running processes:\n";
      log << "Running processes:\n";

      for (auto pid: running) {
        auto& proc = data.get_process(pid);
        auto line = format(
          "  {:<10} ({})  Core: {:<2}  {} / {}\n",
          proc.data.name,
          timestamp(proc.data.stime),
          proc.data.core_id,
          proc.data.program.ip,
          proc.data.program.size()
        );
        cout << "\033[36m" << line << "\033[0m";
        log << line;
      }

      cout << "\nFinished processes:\n";
      log << "\nFinished processes:\n";

      for (auto pid: finished) {
        auto& proc = data.get_process(pid);
        auto line = format(
          "  {:<10} ({})  Finished      {} / {}\n",
          proc.data.name,
          timestamp(proc.data.stime),
          proc.data.program.size(),
          proc.data.program.size()
        );
        cout << "\033[36m" << line << "\033[0m";
        log << line;
      }

      cout << "\033[38;5;33m" << separator << "\033[0m";
      log << separator;
      log.close();

      cout << "[report-util] Report written to csopesylog.txt\n";
    });
}

------------------------------
 FILE:  scheduler-start.hpp
 PATH:  core\command\handlers\scheduler-start.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/process/Process.hpp"
#include "core/shell/internal/Shell.impl.hpp"


auto make_scheduler_start() -> CommandHandler {
  return CommandHandler()
    .set_name("scheduler-start")
    .set_desc("Starts periodic dummy process generation every 'batch_process_freq' ticks.")
    .set_min_args(0)
    .set_max_args(0)
    .set_flags({})
    
    .set_validate([](Command&, Shell& shell) -> Str {
      auto config = shell.scheduler.data.config;
      
      // Check if the scheduler has already been initialized
      if (!config.getb("initialized"))
        return "Scheduler not initialized. Please run 'initialize' first.";

      if (shell.scheduler.generating)
        return "Dummy process generation already active.";

      return nullopt;
    })
    
    .set_execute([](Command&, Shell& shell) {
      shell.scheduler.generate(true);
      cout << "[Shell] Dummy process generation started.\n";
    });
}

------------------------------
 FILE:  scheduler-stop.hpp
 PATH:  core\command\handlers\scheduler-stop.hpp
------------------------------

#pragma once
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/shell/internal/Shell.impl.hpp"


auto make_scheduler_stop() -> CommandHandler {
  return CommandHandler()
    .set_name("scheduler-stop")
    .set_desc("Stops generating dummy processes.")
    .set_min_args(0)
    .set_max_args(0)
    .set_flags({})
    
    .set_validate([](Command&, Shell& shell) -> Str {
      auto config = shell.scheduler.data.config;
      
      // Check if the scheduler has already been initialized
      if (!config.getb("initialized"))
        return "Scheduler not initialized. Please run 'initialize' first.";

      if (!shell.scheduler.generating)
        return "Dummy process generation is not running.";

      return nullopt;
    })
    
    .set_execute([](Command&, Shell& shell) {
      shell.scheduler.generate(false);
      cout << "[Shell] Dummy process generation stopped.\n";
    });
}

------------------------------
 FILE:  screen.hpp
 PATH:  core\command\handlers\screen.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/scheduler/SchedulerData.hpp"
#include "core/shell/internal/Shell.impl.hpp"


auto make_screen() -> CommandHandler {
  return CommandHandler()
    .set_name("screen")
    .set_desc("Creates and switches through existing screens.")
    .set_min_args(0)
    .set_max_args(0)
    .set_flags({{"-s", true}, {"-r", true}, {"-ls", false}})
    
    .set_validate([](Command& command, Shell& shell) -> Str {
      auto has_ls = command.flags.contains("-ls");
      auto has_s = command.flags.contains("-s");
      auto has_r = command.flags.contains("-r");

      if (has_s + has_ls + has_r > 1)
        return "You must use only one of -s, -r, or -ls.";

      if (!shell.screen.is_main())
        return "Not in the Main Menu.";

      return nullopt;
    })

    .set_execute([&](Command& command, Shell& shell) {
      auto& screen = shell.screen;
      auto& scheduler = shell.scheduler;

      // === -ls: List screen info
      if (command.flags.contains("-ls")) {
        auto& data = scheduler.data;
        auto& config = data.config;
        auto& cores = data.cores;

        auto size = cores.size();
        auto busy = cores.get_busy().size();
        float cpu_util = cores.get_usage() * 100;

        cout << format("CPU Utilization: {:.2f}%\n", cpu_util);
        cout << format("Cores used: {} / {}\n\n", busy, size);
        cout << "\033[38;5;33mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\033[0m\n";
        cout << "Running processes:\n";

        for (uint pid : cores.get_running_pids()) {
          auto& process = data.get_process(pid);
          cout << format(
            "  {:<10} \033[36m({})\033[0m  Core: {:<2}  \033[38;5;208m{} / {}\033[0m\n",
            process.data.name,
            timestamp(process.data.stime),
            process.data.core_id,
            process.data.program.ip,
            process.data.program.size()
          );
        }

        cout << "\nFinished processes:\n";

        for (uint pid : data.finished_pids) {
          auto& process = data.get_process(pid);
          cout << format(
            "  {:<10} \033[36m({})\033[0m  Finished      \033[38;5;208m{} / {}\033[0m\n",
            process.data.name,
            timestamp(process.data.stime),
            process.data.program.ip,
            process.data.program.size()
          );
        }

        cout << "\033[38;5;33mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\033[0m\n";
      }

      // === -s: Spawn and switch to new process screen
      else if (command.flags.contains("-s")) {
        const str& name = command.flags.at("-s");

        auto process_exists = [&](const str& name) -> bool {
          auto& data = scheduler.data;
          return data.has_process(name);
        };

        if (process_exists(name))
          return void(cout << format("Process '{}' already exists\n", name));

        scheduler.generate_process(name);
        cout << format("\nWaiting for process creation: {}", name);
        auto created = false;

        for (uint i = 0; i < 30; ++i) {
          if (scheduler.data.has_process(name)) {
            created = true;
            break;
          }

          with_unlocked([&] {
            sleep_for(200ms);
          });
        }

        if (!created)
          return void(cout << "\nTimed out.\n");

        auto& data = scheduler.data;
        auto& process = data.get_process(name);
        uint pid = process.data.id;

        screen.switch_to(pid);
        cout << "\n";
        cout << format("Process name: {}\n", process.data.name);
        cout << format("ID: {}\n", pid);

        cout << "Logs:\n";
        for (auto& log : process.data.logs)
          cout << format("  {}\n", log);

        auto& program = process.data.program;
        cout << format("Current instruction line: {}\n", program.ip);
        cout << format("Lines of code: {}\n", program.size());
      }

      // === -r: Resume process by name
      else if (command.flags.contains("-r")) {
        auto& name = command.flags.at("-r");
        auto& data = scheduler.data;

        if (!data.has_process(name))
          return void(cout << format("Process <{}> not found.\n", name));

        auto& process = data.get_process(name);
        uint pid = process.data.id;

        screen.switch_to(pid);
        cout << format("Process name: {}\n", process.data.name);
        cout << format("ID: {}\n", pid);

        cout << "Logs:\n";
        for (auto& log: process.data.logs)
          cout << format("  {}\n", log);

        cout << format("Current instruction line: {}\n", process.data.program.ip);
        cout << format("Lines of code: {}\n", process.data.program.size());
      }
    });
}

------------------------------
 FILE:  test.hpp
 PATH:  core\command\handlers\test.hpp
------------------------------

#pragma once
#include "core/shell/internal/Shell.impl.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionInterpreter.hpp"
#include "core/process/Process.hpp"
#include "core/process/ProcessProgram.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"

auto make_test() -> CommandHandler {
  return CommandHandler()
    .set_name("test")
    .set_desc("Spawn and manually step a dummy FOR loop process.")
    .set_min_args(0)
    .set_max_args(0)
    .set_flags({{ "-r", false }})

    .set_execute([](Command& command, Shell& shell) {
      auto& interpreter = InstructionInterpreter::get();
      auto& storage = shell.storage;

      // 0. Reset process if requested
      if (command.flags.contains("-r")) {
        shell.storage.remove("test.process");
        cout << "[loop-test] Dummy process reset.\n";
        return;
      }

      // 1. Spawn process if not already present
      if (!storage.has("test.process")) {
        auto process = Process(999, "test.process", 10);
        storage.set("test.process", move(process));
        cout << "[loop-test] Process created.\n";
        return;
      }

      // 2. Access process
      auto& process = storage.get<Process>("test.process");
      auto& program = process.data.program;

      if (program.finished())
        return void(cout << "[loop-test] Process already finished.");

      // === Debug: Show context stack ===
      cout << "[loop-test] Context Stack:\n";
      cout << program.render_context() << '\n';

      // === Debug: Show instruction list with pointer ===
      cout << "[loop-test] Instruction List:\n";
      cout << program.render_script() << '\n';

      // 3. Step the process
      const bool done = process.step();
      cout << "[loop-test] Process stepped.\n";
      cout << (done ? "Finished." : "Still running.") << '\n';
    });
}

------------------------------
 FILE:  util.hpp
 PATH:  core\command\handlers\util.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/shell/internal/Shell.impl.hpp"


auto make_util() -> CommandHandler {
  return CommandHandler()
    .set_name("report-util")
    .set_desc("Generates a report of running and Finished processes to csopesylog.txt")
    .set_min_args(0)
    .set_max_args(0)
    .set_flags({})

    .set_validate([](Command&, Shell& shell) -> Str {
      if (!shell.screen.is_main())
        return "Not in the Main Menu.";
      return nullopt;
    })

    .set_execute([](Command&, Shell& shell) {
      auto& data = shell.scheduler.data;
      auto running = data.cores.get_running_pids();
      auto& finished = data.finished_pids;

      auto log = ofstream("csopesylog.txt");
      auto separator = "---------------------------------------------\n";

      cout << format("\033[38;5;33m{}\033[0m", separator);
      log << separator;

      cout << "Running processes:\n";
      log << "Running processes:\n";

      for (const auto& pid : running) {
        auto& process = data.get_process(pid);
        auto line = format(
          "  {:<10} ({})  Core: {:<2}  {} / {}\n",
          process.data.name,
          timestamp(process.data.stime),
          process.data.core_id,
          process.data.program.ip,
          process.data.program.size()
        );
        cout << format("\033[36m{}\033[0m", line);
        log << line;
      }

      cout << "\nFinished processes:\n";
      log << "\nFinished processes:\n";

      for (auto& pid: finished) {
        auto& process = data.get_process(pid);
        auto line = format(
          "  {:<10} ({})  Finished      {} / {}\n",
          process.data.name,
          timestamp(process.data.stime),
          process.data.program.size(),
          process.data.program.size()
        );
        cout << format("\033[36m{}\033[0m", line);
        log << line;
      }

      cout << format("\033[38;5;33m{}\033[0m", separator);
      log << separator;
      log.close();

      cout << "[report-util] Report written to csopesylog.txt\n";
    });
}

------------------------------
 FILE:  _all.hpp
 PATH:  core\command\handlers\_all.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/command/CommandHandler.hpp"
#include "cls.hpp"
#include "config.hpp"
#include "demo.hpp"
#include "echo.hpp"
#include "exit.hpp"
#include "initialize.hpp"
#include "process-smi.hpp"
#include "report-util.hpp"
#include "scheduler-start.hpp"
#include "scheduler-stop.hpp"
#include "screen.hpp"
#include "test.hpp"

  
auto get_command_handlers() -> vec<CommandHandler> {
  return {
    make_cls(),
    make_config(),
    make_demo(),
    make_echo(),
    make_exit(),
    make_initialize(),
    make_process_smi(),
    make_report_util(), 
    make_scheduler_start(),
    make_scheduler_stop(),
    make_screen(),
    make_test(),
  };
}

------------------------------
 FILE:  banner.hpp
 PATH:  core\common\constants\banner.hpp
------------------------------

#pragma once
#include <string>

inline const std::string BANNER = R"(
         .dP                                                                        Yb    
       .dP    .ooooo.   .oooo.o  .ooooo.  oo.ooooo.   .ooooo.   .oooo.o oooo    ooo  `Yb  
      dP     d88' `"Y8 d88(  "8 d88' `88b  888' `88b d88' `88b d88(  "8  `88.  .8'     `Yb
      Yb     888       `"Y88b.  888   888  888   888 888ooo888 `"Y88b.    `88..8'      .dP
       `Yb   888   .o8 o.  )88b 888   888  888   888 888    .o o.  )88b    `888'     .dP  
         `Yb `Y8bod8P' 8""888P' `Y8bod8P'  888bod8P' `Y8bod8P' 8""888P'     .8'     dP    
                                           888                          .o..P'            
                                          o888o                         `Y8P'             

                          Like a Real OS, But Not Written in Assembly!        
                              Dicayanan|Maramag|Maunahan|Villaver                         
)";

------------------------------
 FILE:  casts.hpp
 PATH:  core\common\imports\casts.hpp
------------------------------

#pragma once
#include <any>          // for std::any, std::any_cast
#include <cstdint>      // for std::uint32_t
#include <string>       // for std::string
#include <type_traits>  // for std::decay_t
#include <utility>      // for std::forward


// Import error exceptions
using std::bad_any_cast;

// Import standard string conversion functions
using std::stoi;
using std::stof;
using std::stoul;
using std::to_string;

// === Generic any cast function ===
template <typename Type, typename From>
auto cast(From&& x) -> Type {
  using Raw = std::decay_t<From>;

  if constexpr (std::is_same_v<Raw, std::any>)
    return std::any_cast<Type>(x);
  else
    return static_cast<Type>(std::forward<From>(x));
}

// === Aliases for clarity ===
template <typename From> 
auto cast_int(From&& x) -> int { 
  return cast<int>(std::forward<From>(x)); 
}

template <typename From> 
auto cast_uint(From&& x) -> std::uint32_t { 
  return cast<uint32_t>(std::forward<From>(x)); 
}

template <typename From> 
auto cast_str(From&& x) -> std::string {
  return cast<std::string>(std::forward<From>(x)); 
}

------------------------------
 FILE:  chrono.hpp
 PATH:  core\common\imports\chrono.hpp
------------------------------

#pragma once
#include <chrono>
#include <ctime>
#include <optional>


using std::chrono::duration_cast;

// Aliases for duration types
using ms  = std::chrono::milliseconds;
using ns  = std::chrono::nanoseconds;
using sec = std::chrono::seconds;

// Clock and time point
using duration = std::chrono::system_clock::duration;
using Clock = std::chrono::system_clock;
using Time = std::chrono::time_point<std::chrono::system_clock>;
using TimeStruct = std::tm;

// Literal suffixes for values like 10ms, 1s, 250ns
using std::chrono_literals::operator""ms;
using std::chrono_literals::operator""ns;
using std::chrono_literals::operator""s;

/** Returns a formatted timestamp string using current local time. */
auto timestamp(std::optional<Time> tp=std::nullopt, const std::string& fmt="%m/%d/%Y %I:%M:%S%p") -> std::string {
  auto time = Clock::to_time_t(tp.value_or(Clock::now()));
  auto time_struct = TimeStruct();
  localtime_s(&time_struct, &time);

  char buffer[32];
  strftime(buffer, sizeof(buffer), fmt.c_str(), &time_struct);
  return buffer;
}

------------------------------
 FILE:  containers.hpp
 PATH:  core\common\imports\containers.hpp
------------------------------

#pragma once
#include <array>
#include <list>
#include <map>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>


using std::array;
using std::list;
using std::make_pair;
using std::out_of_range;
using std::pair;
using std::queue;
using std::unordered_map;
using std::unordered_set;
using std::vector;

// === Aliases ===
template <typename Type>
using vec = vector<Type>;

template <typename Type>
using set = unordered_set<Type>;

template <typename Key, typename Val>
using ordered_map = std::map<Key, Val>;

template <typename Key, typename Val>
using map = unordered_map<Key, Val>;

------------------------------
 FILE:  conventions.hpp
 PATH:  core\common\imports\conventions.hpp
------------------------------

#pragma once
#include <utility> // for std::forward

#define let auto&&


template <typename Type>
constexpr decltype(auto) forward(Type&& x) noexcept {
  return std::forward<Type>(x);
}

------------------------------
 FILE:  helpers.hpp
 PATH:  core\common\imports\helpers.hpp
------------------------------

#pragma once
#include <cmath>
#include <cstdint>
#include <string>
#include <sstream>


// === Utility functions ===
constexpr auto count_digits(uint32_t n) -> uint32_t {
  return (n == 0) ? 1 : static_cast<int>(std::log10(n)) + 1;
}

constexpr auto pad_left(const std::string& s, uint32_t width, char fill=' ') -> std::string {
  return std::string(width > s.length() ? width - s.length() : 0, fill) + s;
}

------------------------------
 FILE:  io.hpp
 PATH:  core\common\imports\io.hpp
------------------------------

#pragma once
#include <fstream>
#include <iostream>
#include <stdexcept>
#include <string>
#include <sstream>
#include <vector>

  
// I/O utility aliases
using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::flush;
using std::getline;
using std::ios;
using std::ifstream;
using std::ofstream;
using std::ostream;
using std::runtime_error;

// === Utility functions ===
auto read_lines(const std::string& path) -> std::vector<std::string> {
  auto file = std::ifstream(path);
  if (!file) return {};

  auto buffer = std::ostringstream();
  buffer << file.rdbuf();

  auto in = std::istringstream(buffer.str());
  auto lines = std::vector<std::string>();
  lines.reserve(8);

  for (std::string line; std::getline(in, line); )
    lines.emplace_back(std::move(line));

  return lines;
}

------------------------------
 FILE:  locks.hpp
 PATH:  core\common\imports\locks.hpp
------------------------------

#pragma once
#include <mutex>


/**
 * @brief Global mutex protecting all SchedulerData access.
 * 
 * This allows you to leave SchedulerData itself lock-free and instead
 * synchronize externally using a simple with_locked(...) wrapper.
 */
inline std::mutex mtx;

/**
 * @brief Executes a function with exclusive access to scheduler state.
 * 
 * This acquires a scoped lock on the global mutex, executes the
 * function, and returns its result. Automatically unlocks at scope end.
 * 
 * @tparam Func A callable type (lambda, functor, etc.)
 * @param fn The function to execute under lock
 * @return The result of the provided function (supports references and values)
 */
template <typename Func>
decltype(auto) with_locked(Func&& fn) {
  auto guard = std::lock_guard(mtx);
  return std::forward<Func>(fn)();
}

/**
 * @brief Temporarily releases the global lock to execute a function without holding it.
 * 
 * This is meant to be used **inside a with_locked section**, where the lock is
 * manually unlocked for the duration of this function and re-locked afterward.
 */
template <typename Func>
decltype(auto) with_unlocked(Func&& fn) {
  mtx.unlock();
  try {
    std::forward<Func>(fn)(); // Optional intermediate
    mtx.lock();  // re-lock before returning
  } catch (...) {
    mtx.lock();  // re-lock even if an exception is thrown
    throw;
  }
}

------------------------------
 FILE:  misc.hpp
 PATH:  core\common\imports\misc.hpp
------------------------------

#pragma once
#include <algorithm>  // required for all_of / any_of to work for some reason??
#include <any>
#include <cctype>
#include <cstdint>
#include <functional>
#include <limits>
#include <optional>
#include <ranges>
#include <string>
#include <type_traits>
#include <utility>

using std::runtime_error;

// === Type Aliases ===
using std::any;
using std::function;
using std::optional;
using byte = uint8_t;
using uint = uint32_t;
using uchar = unsigned char;
using Uint = std::optional<uint>;

// === Aliases ===
template <typename... Args> 
using func = std::function<Args...>;

template <typename Type> 
using ref = std::reference_wrapper<Type>;

template <typename Type> 
using Ref = optional<ref<Type>>;

// === Constants ===
using std::nullopt;

// === STL Utility Aliases ===
using std::ranges::all_of;
using std::ranges::any_of;
using std::ranges::count_if;
using std::ranges::find_if;
using std::ranges::none_of;
using std::any_cast;
using std::cref;
using std::erase_if;
using std::move;
using std::forward;
using std::swap;

// Iterators
template <typename Type>
auto move_iter(Type it) { 
  return std::make_move_iterator(it); 
}

------------------------------
 FILE:  platform.hpp
 PATH:  core\common\imports\platform.hpp
------------------------------

#pragma once

#if defined(_WIN32)
  #ifndef NOMINMAX
    #define NOMINMAX
  #endif
  #include <windows.h>
  void enable_unicode() {
    SetConsoleOutputCP(CP_UTF8);
  }
#else
  #include <locale>
  #include <iostream>
  void enable_unicode() {
    std::ios_base::sync_with_stdio(false);
    std::setlocale(LC_ALL, "");
    std::wcout.imbue(std::locale(""));
  }
#endif

#include <algorithm>
using std::min;
using std::max;

------------------------------
 FILE:  pointers.hpp
 PATH:  core\common\imports\pointers.hpp
------------------------------

#pragma once
#include <memory>


using std::make_unique;
using std::make_shared;

// === Aliases ===

template <typename Type>
using uptr = std::unique_ptr<Type>;

template <typename Type>
using sptr = std::shared_ptr<Type>;

------------------------------
 FILE:  random.hpp
 PATH:  core\common\imports\random.hpp
------------------------------

#pragma once
#include <algorithm>
#include <cstdlib>
#include <ctime>
#include <random>
#include <stdexcept>
#include "casts.hpp"
#include "containers.hpp"
#include "misc.hpp"


/** Random utility class */
class Rand {
  using mt19937   = std::mt19937;
  using int_dist  = std::uniform_int_distribution<>;
  using uint_dist = std::uniform_int_distribution<unsigned>;
  using real_dist = std::uniform_real_distribution<float>;

  inline static mt19937 rng = mt19937(std::random_device{}());

public:

  /** Random signed integer in [min, max] */
  static int num(int min, int max) {
    auto dist = int_dist(min, max);
    return dist(rng);
  }

  /** Random unsigned integer in [min, max] */
  static auto num(uint min, uint max) -> uint {
    auto dist = uint_dist(min, max);
    return dist(rng);
  }

  /** Returns true with probability 1/odds */
  static auto chance(uint odds) -> bool {
    return odds != 0 && num(1u, odds) == 1u;
  }

  /** Random float in [min, max) */
  static auto real(float min, float max) -> float {
    auto dist = real_dist(min, max);
    return dist(rng);
  }

  /** Pick a Random element from a non-empty vector */
  template <typename Type>
  static auto pick(Type&& list) -> decltype(auto) {
    if (list.empty())
      throw runtime_error("Cannot pick from empty list.");
    return std::forward<Type>(list)[num(0, static_cast<int>(list.size()) - 1)];
  }

  /** Shuffle a vector in place */
  template <typename Type>
  static auto shuffle(std::vector<Type>& list) -> std::vector<Type>& {
    std::shuffle(list.begin(), list.end(), rng);
    return list;
  }
};

------------------------------
 FILE:  string.hpp
 PATH:  core\common\imports\string.hpp
------------------------------

#pragma once
#include <algorithm>  // needed for all_of to work for some reason??
#include <cctype>
#include <charconv>
#include <format>
#include <string>
#include <sstream>
#include <optional>
#include <ranges>


// === String Aliases ===
using std::string;
using str = std::string;
using Str = std::optional<string>;
using std::literals::string_literals::operator""s;

// === Character Utilities ===
using std::isalpha;
using std::isalnum;

// === Stream Aliases ===
using std::stringstream;
using std::istringstream;
using std::ostringstream;
using sstream = std::stringstream;
using isstream = std::istringstream;
using osstream = std::ostringstream;

// === Formatting & Parsing ===
using std::format;
using std::errc;
using std::from_chars;

// === Constants ===
constexpr auto NPOS = string::npos;

// === Validation ===

/** @brief Returns true if the string consists only of digit characters (0â€“9). */
auto is_digits(const std::string& s) -> bool {
  return !s.empty() && std::ranges::all_of(s, [](char c) {
    return std::isdigit(static_cast<unsigned char>(c));
  });
}

// === Case conversions ===

/** @brief Returns a lowercase copy of the given string. */
auto lowercase(str raw) -> str {
  for (char& c: raw)
    c = tolower(c);
  return raw;
}

------------------------------
 FILE:  thread.hpp
 PATH:  core\common\imports\thread.hpp
------------------------------

#pragma once
#include <atomic>
#include <condition_variable>
#include <mutex>
#include <shared_mutex>
#include <thread>


// === Atomic Types ===
using std::atomic;
using std::atomic_bool;
using std::atomic_int;
using std::atomic_uint;
using std::atomic_bool;
using aint = std::atomic_int;
using auint = std::atomic_uint;

// === Locking & Threading Aliases ===
using std::lock_guard;
using std::mutex;
using std::shared_lock;
using std::shared_mutex;
using std::this_thread::sleep_for;
using std::unique_lock;
using Thread = std::thread;
using convar = std::condition_variable;

// === Scoped Lock Execution Context ===
struct Context {
  /**
   * @brief Acquires an exclusive lock using std::mutex.
   * @param mtx The mutex to lock.
   * @param fn The function to execute within the lock.
   */
  template <typename Func>
  void lock(mutex& mtx, Func&& fn) const {
    auto guard = lock_guard(mtx);
    std::forward<Func>(fn)();
  }

  /**
   * @brief Acquires an exclusive lock using std::mutex and passes the lock to the function.
   * @param mtx The mutex to lock.
   * @param fn The function to execute with the lock passed as argument.
   */
  template <typename Func>
  void unique(mutex& mtx, Func&& fn) const {
    auto lock = unique_lock(mtx);
    std::forward<Func>(fn)(lock);
  }
};

// === Scoped Context Instance ===
inline constexpr Context with;

------------------------------
 FILE:  _all.hpp
 PATH:  core\common\imports\_all.hpp
------------------------------

#pragma once
#include "locks.hpp"
#include "casts.hpp"
#include "chrono.hpp"
#include "containers.hpp"
#include "conventions.hpp"
#include "helpers.hpp"
#include "io.hpp"
#include "misc.hpp"
#include "platform.hpp"
#include "pointers.hpp"
#include "random.hpp"
#include "string.hpp"
#include "thread.hpp"

------------------------------
 FILE:  Ansi.hpp
 PATH:  core\common\utility\Ansi.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


class Ansi {

  public:

  static void enable() {
    auto handle = GetStdHandle(STD_OUTPUT_HANDLE);
    auto mode = DWORD(0);
    
    if (!GetConsoleMode(handle, &mode))
      return void(cerr << "Failed to get console mode.\n");

    mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
    if (!SetConsoleMode(handle, mode)) 
      return void(cerr << "Failed to enable ANSI escape sequences.\n");
  }
  
  static void set_title(ostream& out, const str& title) {
    out << "\033]0;" << title << "\a";
  }

  static void enter_alt_buffer(ostream& out) {
    out << "\033[?1049h";
  }

  static void exit_alt_buffer(ostream& out) {
    out << "\033[?1049l";
  }

  static void hide_cursor(ostream& out) {
    out << "\033[?25l";
  }

  static void show_cursor(ostream& out) {
    out << "\033[?25h";
  }

  static void clear_screen(ostream& out) {
    out << "\033[2J\033[H";
  }

  static void move_cursor(ostream& out, int row, int col) {
    out << "\033[" << row << ";" << col << "H";
  }
};

------------------------------
 FILE:  EventEmitter.hpp
 PATH:  core\common\utility\EventEmitter.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"

struct EventHandler {
  using func = function<void(const any&)>;
  uint id;
  func fn;
};

/**
 * @class EventEmitter
 * @brief Thread-safe event emitter system.
 * 
 * Enables multiple threads to register event handlers, emit named events 
 * with optional data, and process the queued events. Supports blocking wait 
 * for event availability.
 */
class EventEmitter {
  using atomic = atomic_uint;
  using pair = pair<str, any>;
  using list = vector<pair>;
  using obj  = EventHandler;
  using func = EventHandler::func;
  using task = function<void()>;
  using objs = vector<obj>;
  using map  = unordered_map<str, objs>;

  map    listeners;   ///< Map of event name to handlers
  list   events;      ///< Queue of emitted events
  convar cv;          ///< Condition variable for blocking waits
  atomic next_id = 1; ///< Atomic counter for unique handler IDs
  mutex  mtx;         ///< Mutex for thread safety

  public:
  
  /**
   * @brief Register a handler for a named event.
   * @param name The event name.
   * @param handler A function to call when the event is dispatched.
   * @return uint The unique handler ID assigned to the registered handler.
   */
  uint on(str name, func handler) {
    uint id = next_id++;
    return on(id, move(name), move(handler));
  }

  /**
   * @brief Register a simple handler for a named event with no payload.
   * @param name The event name.
   * @param handler A function to call when the event is dispatched (ignores any payload).
   * @return The unique handler ID assigned to this registration.
   */
  uint on(str name, task handler) {
    return on(move(name), [handler=move(handler)](const any&) { 
      handler(); 
    });
  }

  /**
   * @brief Register a one-time handler for a named event.
   * The handler will be called once, then automatically unregistered.
   * 
   * @param name The event name.
   * @param handler The function to call once.
   */
  void once(str name, func handler) {
    uint id = next_id++; 
    on(id, name, [this, id, name=move(name), handler=move(handler)](const any& payload) {
      off(name, id);    // passes name by value to on(), 
      handler(payload); // then moves into lambda capture
    });
  }

  /**
   * @brief Unregister a handler by ID for a specific event.
   * @param name The event name.
   * @param id The handler ID to remove.
   */
  void off(const str& name, uint id) {
    with.lock(mtx, [&] {
      auto it = listeners.find(name);
      if (it != listeners.end())
        erase_if(it->second, [&](const obj& h) { return h.id == id; });
    });
  }

  /**
   * @brief Unregister all handlers for a specific event.
   * @param name The event name for which all handlers will be removed.
   */
  void off(const str& name) {
    with.lock(mtx, [&] {
      auto it = listeners.find(name);
      if (it != listeners.end())
        listeners.erase(it);          // Remove key and its values from map completely O(1) avg
    });
  }

  /**
   * @brief Emit an event with data.
   * Queues the event and notifies any thread waiting for events.
   * 
   * @param name The event name.
   * @param payload The data to pass to handlers.
   */
  void emit(str name, any payload={}) {
    with.lock(mtx, [&] { 
      events.emplace_back(move(name), move(payload));
    });
    cv.notify_one();
  }

  /**
   * @brief Dispatches all queued events to their registered handlers.
   * 
   * Safely callable from any thread. This method swaps out the event queue
   * under a lock and proc_table a copy of it outside the lock to avoid
   * blocking other operations. For each event, the list of handlers is
   * also copied under a lock to prevent concurrent modification during
   * dispatch. This ensures thread-safe and non-blocking execution of
   * handler callbacks, even if new handlers are added or removed during dispatch.
   */
  void dispatch() {
    list local;
    with.lock(mtx, [&] { local.swap(events); });

    for (const auto& [name, data]: local) {
      objs handlers;

      with.lock(mtx, [&] {
        auto it = listeners.find(name);
        if (it != listeners.end() && !it->second.empty()) // Second condition avoids copying empty list
          handlers = it->second;      // Cant pass by reference cuz handlers is unsafe after lock
      });

      if (handlers.empty()) continue; // Skip if there are no handlers
      for (const auto& handler: handlers) 
        handler.fn(data);
    }
  }

  /**
   * @brief Block until at least one event is queued, then dispatch it.
   * Uses a condition variable to efficiently wait until work is available.
   */
  void wait_dispatch() {
    with.unique(mtx, [&](auto& lock) {
      cv.wait(lock, [&] { return !events.empty(); });
    });
    dispatch();
  }

  private:
  /**
   * @brief Internal registration helper to associate a handler with an explicit ID.
   * @param id A preassigned handler ID.
   * @param name The event name.
   * @param handler The function to register.
   * @return The same ID passed in.
   */
  uint on(uint id, str name, func handler) {
    with.lock(mtx, [&] { 
      listeners[move(name)].emplace_back(id, move(handler)); 
    });
    return id;
  }
};

------------------------------
 FILE:  Core.hpp
 PATH:  core\execution\Core.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/process/Process.hpp"


/**
 * @brief Represents a passive simulated CPU core that ticks independently in a thread.
 * 
 * Responsibilities:
 * - Continuously ticks in its own thread every 1ms to simulate real-time execution.
 * - Executes (`step()`) the currently assigned process one instruction per tick.
 * - Monitors its assigned process for completion or preemption conditions.
 * - Sets `can_release = true` to signal readiness for job release.
 * 
 * Key Behaviors:
 * - Does **not** assign or release proc_table â€” only the **Scheduler** can do that.
 * - Ignores ticking if no process is assigned (`job == nullptr`) or if marked `can_release`.
 * - Calls a user-provided preemption handler, if any, to check for early release.
 * - Tracks how long a job has been running via `job_ticks`.
 * 
 * Design Notes:
 * - Core runs **faster** than the scheduler (1ms tick vs. ~100ms scheduler tick).
 * - Implements `assign()` and `release()` methods, but only for use by the scheduler.
 * - Internally manages its own thread and guarantees safe shutdown in destructor.
 * - Tick behavior is guarded to avoid dereferencing null process pointers.
 * - Cannot crash from invalid job access â€” fully guarded and thread-safe by design.
 */
class Core {
  public:
  using func = func<bool(Core&)>;

  /** @brief Constructs a core with the given ID and starts the thread. */
  Core(uint id=0): 
    id          (id),                 // Core ID
    job_ticks   (0),                  // Number of ticks the current process has been running
    can_release (false),              // Whether the process is eligible for release by the Scheduler
    job         (nullptr),            // Pointer to the currently assigned process (if any)
    preempt     (nullptr),            // Optional strategy-injected logic
    active      (atomic_bool{true}),  // Atomic flag for tick loop, mark the core as active/busy
    thread      ()                    // Background ticking thread
  { 
    // Launch the background thread that ticks continuously
    thread = Thread([this] { 
      while (active) {
        tick();
        sleep_for(1ms);
      }
    });
  }

  /** @brief Destructor stops the tick thread cleanly. */
  ~Core() { stop(); }

  /** @brief Called by scheduller to assign a process to this core. */
  void assign(Process& process) { set_job(&process, id); }

  /** @brief Called only by the scheduler to release the current job. */
  void release() { if (job) set_job(nullptr); }

  /** @brief Returns true no process is assigned to the core. */
  auto is_idle() -> bool { return job == nullptr; }

  /** @brief Returns the currently assigned job. */
  auto get_job() -> Process& {
    if (job) return *job;
    throw runtime_error("Core::get_job: No job is currently assigned");
  }

  /** @brief Injects a preemption handler (optional). */
  void set_preempt(func handler) { preempt = handler; }     

  // ------ Member variables ------

  uint id;                      
  uint job_ticks;       
  bool can_release;   
  Process* job; 
  func preempt;    
  atomic_bool active;   
  Thread thread; 

  // ------ Internal logic ------

  private:

  /** @brief Performs one CPU tick: steps the assigned process if valid. */
  void tick() {
    if (job == nullptr) return; // If no process is assigned to this core, skip the tick
    if (can_release) return;    // Prevent ticking the process if it's already marked for release

    auto& process = *job;       // Get the process from the process pointer
    process.step();             // Execute one instruction from the process script
    ++job_ticks;                // Track how long this process is running on this core

    // If the process has finished all its instructions, mark for release
    if (process.data.program.finished())
      can_release = true;

    // If preemption is defined and it says to preempt, mark for release
    if (preempt != nullptr && preempt(*this))
      can_release = true;
  }

  /** @brief Signals the core to stop and joins the thread cleanly. */
  void stop() {
    active = false;             // Signals the thread to stop
    if (thread.joinable())      // Only joins if the thread is valid
      thread.join();            // Waits for the thread to finish
  }

  // ------ Helper methods ------

  /** @brief Assigns or clears the process currently running on this core. */
  void set_job(Process* process, int core_id=-1) {
    if (process != nullptr)     // Assigning a new process? Mark it with this core's ID
      process->data.core_id = core_id;
    
    job = process;              // Update process pointer slot (null if releasing)
    job_ticks = 0;              // Reset job tick counter â€” either a new job or clearing old one
    can_release = false;        // Always reset release flag; only tick() will set it to true when appropriate
  }    
};

------------------------------
 FILE:  CoreManager.hpp
 PATH:  core\execution\CoreManager.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/execution/Core.hpp"


/**
 * @brief Manages the pool of Core components for the scheduler system.
 * 
 * Responsibilities:
 * - Owns and maintains all simulated CPU cores as `Core` objects.
 * - Provides safe and filtered access to all, busy, or idle cores.
 * - Handles core lifecycle: creation, reset, and safe iteration.
 * 
 * Key Behaviors:
 * - `resize(size)`: Replaces all cores with a new set of N fresh cores.
 * - `get_busy()` / `get_idle()`: Filters out cores by status for use in scheduling logic.
 * - `get_usage()`: Returns a float utilization ratio (busy / total cores).
 * - `get_running_pids()` and `get_busy_core_ids()`: Extract diagnostic metadata from active cores.
 * 
 * Design Notes:
 * - vec<uptr<Core>> are stored as `uptr<Core>` to ensure clean ownership and destruction.
 * - Always use reference-returning accessors (`vec<ref<Core>>`) instead of raw pointer access.
 * - Guards against null pointers even though `resize()` always populates all slots.
 * - Scheduler is the only component expected to use this class directly.
 */
class CoreManager {
  public:

  CoreManager():
    cores (vec<uptr<Core>>()) {}  // Vector contianer for cores

  /** @brief Clears and reinitializes the core list with the specified number of cores */
  void resize(uint size) {
    cores.clear();                // Destroys all existing cores
    cores.reserve(size);          // Preallocate to avoid reallocations
    for (uint i=0; i < size; ++i)
      cores.emplace_back(make_unique<Core>(i+1));
  }

  /** @brief Returns number of cores. */
  auto size() -> uint { return cores.size(); }
  
  /** @brief Returns the current CPU core utilization as a float [0.0, 1.0]. */
  auto get_usage() -> float {
    return cores.empty() ? 0.f : float(get_busy_size()) / float(cores.size());
  }

  /** @brief Access a specific core by index. */
  auto get(uint i) -> Core& { return *cores.at(i); }

  /** @brief Returns references to all cores. */
  auto get_all() -> vec<ref<Core>> { return filter_cores([](auto& ptr) { return true; }); }

  /** @brief Returns a list of references to all idle cores. */
  auto get_idle() -> vec<ref<Core>> { return filter_cores([](auto& ptr) { return ptr->is_idle(); }); }

  /** @brief Returns a list of references to all busy (non-idle) cores. */
  auto get_busy() -> vec<ref<Core>> { return filter_cores([](auto& ptr) { return !ptr->is_idle(); }); }
  
  /** @brief Returns a list of references to all busy (non-idle) and releasable  cores. */
  auto get_releasable() -> vec<ref<Core>> { return filter_cores([](auto& ptr) { return !ptr->is_idle() && ptr->can_release; }); }

  /** @brief @brief Returns a list of IDs for all busy (non-idle) cores. */
  auto get_busy_core_ids() -> vec<uint> { return extract_ids([](auto& core) { return core.id; }); }

  /** @brief Returns a list of pids to all busy (non-idle) cores. */
  auto get_running_pids() -> vec<uint> { return extract_ids([](auto& core) { return core.get_job().data.id; }); }

  // ------ Internal logic ------

  private:

  // ------ Member variables ------
  vec<uptr<Core>> cores;

  // ------ Helper Methods ------

  /** @brief Returns the number of currently busy (non-idle) cores. */
  auto get_busy_size() -> uint {
    return count_if(cores, [](auto& ptr) { return ptr != nullptr && !ptr->is_idle(); });
  }

  /** @brief Returns references to cores that satisfy the given filter condition. */
  template <typename Func = bool(*)(uptr<Core>&)>
  auto filter_cores(Func func) -> vec<ref<Core>> {
    auto result = vec<ref<Core>>();     // Create a list of core reference wrappers
    result.reserve(cores.size());       // Optional: preallocate to avoid reallocations

    for (auto& ptr: cores)
      if (ptr != nullptr && func(ptr))  // Only include non-null cores that pass the filter
        result.push_back(ref(*ptr));    // Store a reference wrapper of the matching core
    
    return result;
  }

  /** @brief Extracts a list of uint values from all busy cores using the given accessor. */
  template <typename Func = bool(*)(Core&)>
  auto extract_ids(Func func) -> vec<uint> {
    auto busy = get_busy();             // Store once to reuse
    auto result = vec<uint>();
    result.reserve(busy.size());        // Reserve exactly what we need

    for (auto& ref: busy)
      result.push_back(func(ref.get()));

    return result;
  }
};

------------------------------
 FILE:  Instruction.hpp
 PATH:  core\instruction\Instruction.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


/** Represents a single process instruction. */
struct Instruction {
  using Script = vec<Instruction>;

  str opcode;     ///< Operation name, e.g., `FOR`, `PRINT`, etc.
  vec<str> args;      ///< List of string arguments

  /**
   * Metadata: cached exit address for control-flow blocks, e.g., `FOR`, `IF`.
   * Set dynamically to allow skipping. A value of 0 means unset.
   */
  mutable uint exit = 0;
};

------------------------------
 FILE:  InstructionHandler.hpp
 PATH:  core\instruction\InstructionHandler.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "Instruction.hpp"
#include "types.hpp"

class ProcessData; // Forward declaration

/** Represents an executable instruction handler. */
class InstructionHandler {
  public:

  InstructionHandler():
    opcode      (""s),              // The opcode string representing the instruction.
    open_opcode (""s),              // For control instruction with a matching open
    exit_opcode (""s),              // For control instruction with a matching exit
    signatures  (vec<Signature>()), // Describes expected argument types
    execute     (nullptr) {}        // Function to execute the instruction
    
  // Chainable setters
  
  /** @brief Sets the opcode for this instruction. */
  auto set_opcode(str op) -> InstructionHandler { return opcode = move(op), *this; }

  /** @brief Sets the matching open opcode (used by control exit instructions). */
  auto set_open(str op) -> InstructionHandler { return open_opcode = move(op), *this; }
  
  /** @brief Sets the matching exit opcode (used by control open instructions). */
  auto set_exit(str op) -> InstructionHandler { return exit_opcode = move(op), *this; }
  
  /** @brief Adds a signature definition to the instruction. */
  auto add_signature(Signature sig) -> InstructionHandler { return signatures.push_back(move(sig)), *this; }
  
  /** @brief Sets the execution function for this instruction. */
  auto set_execute(func<void(Instruction&,ProcessData&)> fn) -> InstructionHandler { return execute = move(fn), *this; }

  /** @brief Returns true if this instruction begins a open control block (e.g., FOR). */
  auto is_control_open() -> bool { return !exit_opcode.empty(); }

  /** @brief Returns true if this instruction begins a exit control block (e.g., FOR). */
  auto is_control_exit() -> bool { return !open_opcode.empty(); }

  /** Generates a random instruction based on the signature. */
  auto generate() -> Instruction {
    auto inst = Instruction(opcode);
    if (signatures.empty()) return inst;

    auto& sig = Rand::pick(signatures);
    inst.args = sig.generate();
    return inst;
  }

  // ------ Member variables ------

  str opcode;                                     
  str open_opcode;                                
  str exit_opcode;                                
  vec<Signature> signatures;    
  func<void(Instruction&,ProcessData&)> execute;  
};

------------------------------
 FILE:  InstructionInterpreter.hpp
 PATH:  core\instruction\InstructionInterpreter.hpp
------------------------------

#pragma once
#include "core/instruction/handlers/_all.hpp"
#include "core/process/ProcessData.hpp"
#include "InstructionHandler.hpp"
#include "Instruction.hpp"


/** Central registry and dispatcher for all instruction types. */
class InstructionInterpreter {
  private:
  
  /** 
   * Private constructor to enforce singleton access via get().
   * Initializes and registers all handlers once. 
   */
  InstructionInterpreter():
    handlers         (map<str,InstructionHandler>()),   // opcode -> handler
    all_handlers     (vec<ref<InstructionHandler>>()),  // cached reference list for introspection
    flat_handlers    (vec<ref<InstructionHandler>>()),  // Handlers for non-control instructions
    control_handlers (vec<ref<InstructionHandler>>())   // Handlers for control instructions
  {
    for (auto& inst: get_instruction_handlers())
      register_instruction(move(inst));

    // Categorize and cache handler references for quick lookup
    all_handlers.reserve(handlers.size());

    for (auto& [_, handler]: handlers) {
      all_handlers.push_back(ref(handler));  // Add to full list

      // Separate into control vs. flat based on metadata
      if (handler.is_control_exit()) continue;
      if (handler.is_control_open())
        control_handlers.push_back(ref(handler));
      else
        flat_handlers.push_back(ref(handler));
    }
  }

  public:

  /** Returns the global singleton get of the InstructionInterpreter. */
  static auto get() -> InstructionInterpreter& {
    static auto inst = InstructionInterpreter();
    return inst;
  }

  /** Registers a handler by opcode. */
  void register_instruction(InstructionHandler handler) {
    handlers[handler.opcode] = move(handler);
  }

  /** Execute an instruction using its handler. */
  void execute(Instruction& inst, ProcessData& proc) {
    auto it = handlers.find(inst.opcode);
    if (it == handlers.end())
      throw runtime_error("Unknown instruction: " + inst.opcode);

    it->second.execute(inst, proc);
  }

  /**
   * Generates a random list of up to `size` instructions with proper block closure.
   * May exceed size due to necessary ENDFOR-like closures.
   */
  auto generate_script(uint size, uint max_depth=3) -> Instruction::Script {
    auto script = Instruction::Script();
    auto stack = vec<ref<InstructionHandler>>();  // Tracks opened control blocks

    while (script.size() < size) {
      if (should_open(stack, max_depth))          // For opening control instructions
        open_control_block(script, stack);
      
      else if (should_close(stack))               // For closing control instructions
        close_control_block(script, stack);

      if (!flat_handlers.empty())                 // For adding flat instructions
        script.push_back(Rand::pick(flat_handlers).get().generate());
    }

    // Auto-close any unclosed control blocks
    while (!stack.empty())
      close_control_block(script, stack);

    return script;
  }

  // ------ Member variables ------

  map<str,InstructionHandler> handlers;           
  vec<ref<InstructionHandler>> all_handlers;      
  vec<ref<InstructionHandler>> flat_handlers;     
  vec<ref<InstructionHandler>> control_handlers;

  // ------ Internal helpers ------

  /** Returns true if a control block can be opened (depth-limited, random chance). */
  bool should_open(vec<ref<InstructionHandler>>& stack, uint max_depth) { 
    return !control_handlers.empty() && (stack.size() < max_depth) && Rand::chance(4); 
  }

  /** Returns true if a control block can be closed (if any open, random chance). */
  bool should_close(vec<ref<InstructionHandler>>& stack) { 
    return !stack.empty() && Rand::chance(4); 
  }

  /** Emits a random control-opener instruction and pushes it to the stack. */
  void open_control_block(Instruction::Script& script, vec<ref<InstructionHandler>>& stack) {
    auto& handler = Rand::pick(control_handlers);
    script.push_back(handler.get().generate());
    stack.push_back(handler);
  }

  /** Emits the matching end-opcode of the current open control block. */
  void close_control_block(Instruction::Script& script, vec<ref<InstructionHandler>>& stack) {
    if (stack.empty())
      throw runtime_error("Attempted to emit ENDFOR with empty control stack!");
    
    auto& opener = stack.back();
    script.emplace_back(opener.get().exit_opcode);
    stack.pop_back();
  }
};

------------------------------
 FILE:  types.hpp
 PATH:  core\instruction\types.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


/** @brief Represents one argument in an instruction signature. */
class Arg {
  public:

  Arg(str type, uint min=0, uint max=0): 
    type (move(type)),  // Parameter type: "str", "uint", or "var"
    min  (min),         // Minimum value (for "uint" type)
    max  (max) {}       // Maximum value (for "uint" type)
  
  // ------ Member variables ------
  str type; 
  uint min; 
  uint max; 
};

/** @brief Builder for defining and generating argument signatures for instructions. */
class Signature {
  public:

  Signature(): 
    args(vec<Arg>()) {}   // Initializes an empty signature

  // === Builders ===

  /** @brief Adds a string argument. */
  auto Str() -> Signature& { return add("str"); }

  /** @brief Adds a variable name argument. */
  auto Var() -> Signature& { return add("var"); }

  /** @brief Adds an unsigned integer argument. */
  auto Uint(uint min, uint max) -> Signature& { return add("uint", min, max); }

  /** @brief Adds an unsigned 8-bit integer argument (0â€“255). */
  auto Uint8() -> Signature& { return Uint(0, 255); }

  /** @brief Adds an unsigned 16-bit integer argument (0â€“65535). */
  auto Uint16() -> Signature& { return Uint(0, 65535); }

  // === Accessors ===

  /** @brief Returns the full list of argument specs. */
  auto get() -> vec<Arg>& { return args; }

  /** @brief Returns the number of arguments in the signature. */
  auto size() -> uint { return args.size(); }

  // === Generator (optional utility) ===

  /** @brief Generates a list of example argument values matching the signature. */
  auto generate() -> vector<str> {
    auto result = vector<str>();
    for (auto& arg: args) {
      if (arg.type == "uint")     result.push_back(to_string(Rand::num(arg.min, arg.max)));
      else if (arg.type == "str") result.push_back(Rand::pick(messages));
      else if (arg.type == "var") result.push_back(Rand::pick(vars));
      else                        result.push_back("<?>");
    }
    return result;
  }

  private:

  // ------ Member variables ------
  vec<Arg> args;

  // ------ Constants ------
  inline static  auto messages = vec<str>{ "hello", "world", "lorem", "ipsum", "test" };
  inline static  auto vars = vec<str>{ "x", "y", "z" };

  // ------ Internal Helpers ------
  
  /** @brief Adds a generic argument of given type and optional bounds. */
  auto add(str type, uint min=0, uint max=0) -> Signature& { 
    return args.emplace_back(move(type), min, max), *this; 
  }
};

------------------------------
 FILE:  add.hpp
 PATH:  core\instruction\handlers\add.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionParam.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/process/ProcessData.hpp"


inline InstructionHandler make_add() {
  using Param = InstructionParam;
  return {
    .opcode = "ADD",
    .signatures = {
      { Param::Var(), Param::Var(),    Param::Var() },    // ADD var, var, var
      { Param::Var(), Param::Var(),    Param::UInt16() }, // ADD var, var, val
      { Param::Var(), Param::UInt16(), Param::UInt16() }, // ADD var, val, val
    },
    .execute = [](Instruction& inst, ProcessData& proc) {
      uint lhs = proc.get_memory().get(inst.args[1]);
      uint rhs = proc.get_memory().resolve(inst.args[2]);
      proc.get_memory().set(inst.args[0], lhs + rhs);
    },
  };
}

------------------------------
 FILE:  declare.hpp
 PATH:  core\instruction\handlers\declare.hpp
------------------------------

#pragma once
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/process/ProcessData.hpp"


inline InstructionHandler make_declare() {
  using Param = InstructionParam;
  using list = vector<str>;
  return {
    .opcode = "DECLARE",
    .signatures = {{ Param::Var(), Param::UInt16() }},
    .execute = [](Instruction& inst, ProcessData& proc) {
      uint value = stoul(inst.args[1]);
      proc.get_memory().set(inst.args[0], value);
    },
  };
}


------------------------------
 FILE:  endfor.hpp
 PATH:  core\instruction\handlers\endfor.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/process/ProcessData.hpp"


auto make_endfor() -> InstructionHandler {
  return InstructionHandler()
    .set_opcode("ENDFOR")
    .set_open("FOR")

    .set_execute([](Instruction& inst, ProcessData& process) {
      auto& program = process.program;
      auto& context = program.context;
      auto& frame = context.top();
      auto& frame_inst = program.script.at(frame.ip);

      // Check if block is inside a FOR loop
      if (frame_inst.opcode != "FOR")
        throw runtime_error("[ENDFOR] No matching FOR block on stack.");

      // Cache exit address if it's not set
      if (inst.exit == 0)
        inst.exit = program.ip + 1;

      // Decrement loop count; jump back if more iterations remain
      if (--frame.ctr > 0)
        return void(program.set_ip(frame.ip));

      context.pop();
    });
}

------------------------------
 FILE:  for.hpp
 PATH:  core\instruction\handlers\for.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/instruction/types.hpp"
#include "core/process/ProcessData.hpp"


auto make_for() -> InstructionHandler {
  
  // === Skips ahead to the matching ENDFOR. ===
  auto skip_block = [](auto& program, auto& inst) { 

    cout << "Before: inst.exit = " << inst.exit << "\n";
    
    // Use cached exit if available
    if (inst.exit != 0)
      return void(program.set_ip(inst.exit));
      
    auto& script = program.script;
    uint start = program.ip;
    uint depth = 1;


    // Otherwise, scan ahead to find the matching ENDFOR
    for (uint i = start+1; i < script.size(); ++i) {
      auto& opcode = script[i].opcode;
      int delta = (opcode == "FOR") - (opcode == "ENDFOR");
      depth += delta;
      
      // If matching ENDFOR is found, cache exit address and exit loop
      if (depth == 0) {
        inst.exit = i + 1;
        program.set_ip(inst.exit);
        cout << "After: inst.exit = " << inst.exit << "\n";
        return;
      }
    }
    
    throw runtime_error("[FOR] Mismatched FOR/ENDFOR blocks.");
  };

  return InstructionHandler()
    .set_opcode("FOR")
    .set_exit("ENDFOR")
    .add_signature(Signature().Uint(1, 5))

    .set_execute([&](Instruction& inst, ProcessData& process) {
      auto& program = process.program;
      auto count = stoul(inst.args[0]);

      // Skip if counter is 0
      if (count == 0)
        return skip_block(program, inst);

      auto& context = program.context;
      if (!context.top_ip_is(program.ip))
        context.push(program.ip, count);
    });
}

------------------------------
 FILE:  print.hpp
 PATH:  core\instruction\handlers\print.hpp
------------------------------

#pragma once
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/instruction/types.hpp"
#include "core/process/ProcessData.hpp"


auto make_print() -> InstructionHandler {
  return InstructionHandler()
    .set_opcode("PRINT")
    .add_signature(Signature().Str())
    .add_signature(Signature().Str().Var())
    
    .set_execute([](Instruction& inst, ProcessData& process) {
      process.log(inst.args[0]);
    });
}

------------------------------
 FILE:  sleep.hpp
 PATH:  core\instruction\handlers\sleep.hpp
------------------------------

#pragma once
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/process/ProcessData.hpp"


auto make_sleep() -> InstructionHandler {
  return InstructionHandler()
    .set_opcode("SLEEP")
    .add_signature(Signature().Uint(0, 3))

    .set_execute([](Instruction& inst, ProcessData& process) {
      auto& program = process.program;
      auto& control = process.control;
      auto& context = program.context;

      // Phase 1: First-time setup
      if (!context.top_ip_is(program.ip)) {
        context.push(program.ip);               // Mark SLEEP as active on the context stack
        control.sleep_for(stoul(inst.args[0])); // Start sleep for given duration (in ticks)
      }

      // Phase 2: Sleep body
      if (!control.sleeping())                  // Done sleeping, remove context frame
        context.pop();        

      else {                                    
        control.tick();                         // Still sleeping, consume one tick
        program.set_ip(program.ip);             // Block ip auto-increment by setting manually
      }
    });
}

------------------------------
 FILE:  subtract.hpp
 PATH:  core\instruction\handlers\subtract.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionParam.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/process/ProcessData.hpp"


inline InstructionHandler make_subtract() {
  using Param = InstructionParam;
  return {
    .opcode = "SUBTRACT",
    .signatures = {
      { Param::Var(), Param::Var(),    Param::Var() },    // ADD var, var, var
      { Param::Var(), Param::Var(),    Param::UInt16() }, // ADD var, var, val
      { Param::Var(), Param::UInt16(), Param::UInt16() }, // ADD var, val, val
    },
    .execute = [](Instruction& inst, ProcessData& proc) {
      uint lhs = proc.get_memory().get(inst.args[1]);
      uint rhs = proc.get_memory().resolve(inst.args[2]);
      proc.get_memory().set(inst.args[0], (lhs > rhs) ? (lhs-rhs) : 0);
    },
  };
}

------------------------------
 FILE:  _all.hpp
 PATH:  core\instruction\handlers\_all.hpp
------------------------------

#pragma once
#include "core/instruction/InstructionHandler.hpp"
// #include "add.hpp"
// #include "declare.hpp"
#include "endfor.hpp"
#include "for.hpp"
#include "print.hpp"
#include "sleep.hpp"
// #include "subtract.hpp"


auto get_instruction_handlers() -> vec<InstructionHandler> {
  return {
    // make_add(),
    // make_declare(),
    make_endfor(),
    make_for(),
    make_print(),
    make_sleep(),
    // make_subtract(),
  };
}

------------------------------
 FILE:  .gitkeep
 PATH:  core\memory\.gitkeep
------------------------------


------------------------------
 FILE:  Maze.hpp
 PATH:  core\misc\Maze\Maze.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "Position.hpp"

namespace csopesy {
  class Maze {
    using list    = vector<int>;
    using Symbols = array<str, 17>;
    using Row     = vector<byte>;
    using Grid    = vector<Row>;

    static constexpr byte PATH = 0;
    static constexpr byte STEP = 16;
    static constexpr byte WALL = 255;
    inline static const Symbols symbols = {
      " ", "â•‘", "â•", "â•”", "â•", "â•—", "â•", "â•¦",
      "â•‘", "â•‘", "â•š", "â• ", "â•", "â•£", "â•©", "â•¬",
      "Â·",
    };

    uint width;
    uint height;
    Grid grid;

    public:
    Maze(uint width, uint height): 
      width(width), 
      height(height), 
      grid(height, Row(width, WALL)) {
      generate();
    }

    str render() const {
      auto stream = osstream();
      for (const auto& row: grid) {
        for (const auto& cell: row)
          stream << symbols[cell];
        stream << '\n';
      }
      return stream.str();
    }

    private:
    bool in_bounds(int x, int y) const {
      return x >= 0 && x < width && y >= 0 && y < height;
    }

    bool is_wall(int x, int y) const {
      return grid[y][x] != PATH;
    }

    void generate() {
      using Position::pos;

      list dirs  = { pos(1,0), pos(0,1), pos(-1,0), pos(0,-1) };
      list stack = { pos(1,1) };
      stack.reserve((width * height) / 2);
      
      while (!stack.empty()) {
        // Pop the current cell (top of the stack)
        auto [x, y] = pos(stack.back());
        stack.pop_back();
        
        for (auto dir: Rand::shuffle(dirs)) {
          auto [dx, dy] = pos(dir);
          int nx = x + dx*2;
          int ny = y + dy*2;

          // Choose a random unvisited neighbor
          if (!in_bounds(nx, ny) || !is_wall(nx, ny)) 
            continue;

          // Remove the wall between the current cell and the chosen neighbor
          grid[y+dy][x+dx] = PATH;
          grid[ny][nx] = PATH;

          // Add the current position and the new position to the stack
          stack.push_back(pos(x, y));
          stack.push_back(pos(nx, ny));
          break;
        }
      }

      format();
    }

    void format() {
      for (int y=0; y < height; ++y) {
        for (int x=0; x < width; ++x) {
          // Skip empty spaces
          if (!is_wall(x, y)) continue;

          byte bits = 0;
          if (y > 0 && is_wall(x, y-1))        bits |= 0b1000;  // Check if there's a top wall
          if (x > 0 && is_wall(x-1, y))        bits |= 0b0100;  // Check if there's a left wall
          if (x < width-1 && is_wall(x+1, y))  bits |= 0b0010;  // Check if there's a right wall
          if (y < height-1 && is_wall(x, y+1)) bits |= 0b0001;  // Check if there's a bottom wall

          // Set the grid's value to the correct symbol based on the bitmask
          grid[y][x] = bits;
        }
      }
    }
  };
}

------------------------------
 FILE:  Position.hpp
 PATH:  core\misc\Maze\Position.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"

namespace csopesy::Position {  
  
  // Encode two integers (x, y) into a single integer
  inline int pos(int x, int y) {
    return (x << 16) | (y & 0xFFFF);
  }

  // Decode a single encoded integer back into a position (x, y)
  inline pair<int, int> pos(int encoded) {
    int x = encoded >> 16;
    int y = encoded & 0xFFFF;
    
    // If y is negative, sign-extend it properly
    return { x, (y & 0x8000 ) ? (y | 0xFFFF0000) : y };
  }
}

------------------------------
 FILE:  Process.hpp
 PATH:  core\process\Process.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionInterpreter.hpp"
#include "ProcessData.hpp"


class Process {
  public:  

  /** @brief Creates a process with a random instruction script. */
  Process(uint pid, str name, uint size): 
    data(           // Data container of process
      ProcessData(
        pid,
        move(name),
        move(interpreter.generate_script(size))
      )
    ) {}
  
  /** @brief Appends a log message (e.g. from PRINT instruction). */
  void log(str line) { data.log(move(line)); }

  /** @brief Executes a single instruction step for the given process. */
  auto step() -> bool {
    auto& program = data.program;
    if (program.finished())
      return true;          
      
    auto ip = program.ip; 
    auto& inst = data.program.script.at(ip);
    interpreter.execute(inst, data);

    // Don't auto-advance ip if it was not manually set
    if (!program.ip_was_set)
      program.ip++;
    
    program.ip_was_set = false;
    return false;
  }

  // ------ Member variables ------
  inline static auto& interpreter = InstructionInterpreter::get();
  ProcessData data;
};

------------------------------
 FILE:  ProcessControl.hpp
 PATH:  core\process\ProcessControl.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "ProcessProgram.hpp"


/**
 * @brief Tracks the execution state of a process.
 * 
 * Supports transitions between Ready, Sleeping, and Finished states,
 * and stores the number of ticks remaining for a sleeping process.
 */
class ProcessControl {
  public:

  ProcessControl():
    sleep_ticks (0) {}
  
  /** @brief Returns true if the process is currently sleeping. */
  auto sleeping() const -> bool { return sleep_ticks > 0; }    
  
  /** @brief Puts the process to sleep for a number of ticks. */
  void sleep_for(uint ticks) { sleep_ticks = ticks; }
  
  /** @brief Advances sleep state by one tick, if sleeping. */
  void tick() { if (sleep_ticks > 0) --sleep_ticks; }
  
  // ------ Member variables ------
  uint sleep_ticks;
};

------------------------------
 FILE:  ProcessData.hpp
 PATH:  core\process\ProcessData.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "ProcessMemory.hpp"
#include "ProcessProgram.hpp"
#include "ProcessControl.hpp"
#include "types.hpp"


/**
 * @brief Pure data container for process state.
 * 
 * This class holds all memory, program, state, and metadata
 * related to a single process. It is only accessible by the
 * Process class, which owns and manipulates this data.
 */
class ProcessData {
  public:

  /** @brief Constructs a process given name and process ID. */
  ProcessData(uint id, str name, Instruction::Script script): 
    id      (id),                     // Unique process ID
    name    (move(name)),             // Human-readable process name (e.g. p01, p02)
    logs    (vec<str>()),             // Output logs collected from PRINT instructions
    core_id (0u),                     // ID of the core this process is assigned to (0 if unassigned)
    stime   (Clock::now()),           // Timestamp of when the process was created
    program (ProcessProgram(script)), // List of instructions and execution context
    control (ProcessControl()),       // Sleep controller of the process
    memory  (ProcessMemory()) {}      // Key-value variable store (e.g. for DECLARE, ADD, etc.)

  /** @brief Append a log message (used for PRINT instructions) */
  void log(str line) { logs.push_back(move(line)); }

  // ------ Member variables ------
  uint id;            
  str name;          
  vec<str> logs;         
  uint core_id;       
  Time stime;        
  ProcessProgram program; 
  ProcessControl control; 
  ProcessMemory memory;   
};

------------------------------
 FILE:  ProcessMemory.hpp
 PATH:  core\process\ProcessMemory.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "types.hpp"


class ProcessMemory { 
  public:
  
  ProcessMemory():
    symbol_table (map<str,uint>()) {}

  /** Memory mutators */
  void set(str key, uint value) {
    symbol_table[move(key)] = value;
  }
  
  /** Memory accessors */
  auto get(const str& key) const -> uint {
    auto it = symbol_table.find(key);
    return it != symbol_table.end() ? it->second : 0;
  }
  
  /** Resolves a token as a literal or variable lookup */
  auto resolve(const str& token) const -> uint {
    return isdigit(token[0]) ? stoul(token) : get(token);
  }
  
  /** Exposes internal variable bindings */
  auto get_symbol_table() -> map<str,uint>& {
    return symbol_table;
  }

  // ------ Member variables ------
  map<str,uint> symbol_table;
};

------------------------------
 FILE:  ProcessProgram.hpp
 PATH:  core\process\ProcessProgram.hpp
------------------------------

#pragma once
#include "core/instruction/Instruction.hpp"
#include "types.hpp"

  
/**
 * @brief A program that can be executed by a process.
 * 
 * Contains a flat list of instructions, an instruction pointer,
 * and a control context stack (used by FOR loops).
 */
class ProcessProgram {
  public:

  /** @brief Loads an instruction script. */
  ProcessProgram(Instruction::Script script): 
    script     (Instruction::Script(move(script))),  // Flat list of all program instructions
    context    (ContextStack()),                     // Stack of active loop contexts
    ip_was_set (false),                              // For blocking instruction pointer advancing
    ip         (0) {}                                // Current instruction pointer

  /** @brief Returns the size of the script. */
  auto size() -> uint { return script.size(); }
  
  /** @brief Check if the program has completed execution. */
  auto finished() -> bool { return ip >= script.size(); }

  /** @brief Manually sets the instruction pointer to a specific address. */
  void set_ip(uint addr) {
    ip_was_set = true;
    ip = addr;
  }

  /** @brief Returns a formatted view of all instructions with the current IP highlighted. */
  auto render_script() -> str {
    // Compute the width needed to align inst indices
    uint width = count_digits(script.size()-1);
    auto out = osstream();
    
    // Render each instruction line, marking the current IP with a '>'
    for (uint i=0; i < script.size(); ++i)
      out << render_line(i, width);

    return out.str();
  }

  /** @brief Returns a formatted view of the current context stack. */
  auto render_context() -> str {
    // If there are no loop frames, return empty
    if (context.empty()) 
      return "  <empty>\n";  
    
    // Compute width for formatting inst indices
    uint width = count_digits(script.size()-1); 
    auto out = osstream();

    // Render each loop frame (used by nested FOR instructions)
    for (uint i=0; i < context.size(); ++i)
      out << render_frame(i, width);

    return out.str();
  }

  // ------ Member variables ------

  Instruction::Script script;
  ContextStack context;
  bool ip_was_set;
  uint ip;

  // ------ Internal logic ------

  private:

  /** @brief Helper to renders a single instruction line from the script with formatting. */
  auto render_line(uint idx, uint width) -> str {
    char marker = (idx == ip) ? '>' : ' ';
    auto opcode = script[idx].opcode.substr(0, 10);
    auto line = osstream();
    line << format("{} [{:0{}}] {:<{}}", marker, idx, width, opcode, 10);

    for (auto& arg: script[idx].args)
      line << ' ' << arg;
    line << '\n';

    return line.str();
  }

  /** @brief Helper to renders a single loop frame from the context stack with formatting. */
  auto render_frame(uint idx, uint width) -> str {
    auto& frame = context.at(idx);
    auto& inst = script[frame.ip];
    auto out = osstream();

    out << format("  [{}]", idx);
    out << format(" @{:0{}}", frame.ip, width);
    out << format("  exit: {:0{}}", inst.exit, width);
    out << format("  count: {}", frame.ctr);
    out << '\n';
    return out.str();
  }
};

------------------------------
 FILE:  types.hpp
 PATH:  core\process\types.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"


/** A loop frame from a FOR-like instruction. */
struct ContextFrame {
  uint ip;    // Address where the loop starts
  uint ctr;   // Number of iterations remaining
};

/**
  * @brief A stack structure used for managing nested FOR loop contexts.
  * 
  * Stores control frames for tracking loop entry points, exit conditions, 
  * and iteration counts during process execution. Could also be used to
  * track sleep.
  */
class ContextStack {
  public:

  ContextStack():
    stack (vec<ContextFrame>()) {}

  /** Returns true if the top frame starts at the given instruction pointer. */
  auto top_ip_is(uint ip) -> bool {  return !empty() && top().ip == ip; }

  /** Push a new context onto the stack. */
  void push(uint start, uint count=0) { stack.emplace_back(start, count); }

  /** Pop the top context from the stack. */
  void pop() { stack.pop_back(); }

  /** Check if the context stack is empty. */
  auto empty() -> bool { return stack.empty(); }

  /** Get the number of contexts in the stack. */
  auto size() -> uint { return stack.size(); }

  /** Clear all contexts from the stack. */
  void clear() { stack.clear(); }

  /** Access the top context */
  auto top() -> ContextFrame& { return stack.back(); }

  /** Access a context by index. */
  auto at(uint index) -> ContextFrame& { return stack.at(index); }

  private:

  // ------ Member variables ------
  vec<ContextFrame> stack;
};

------------------------------
 FILE:  Scheduler.hpp
 PATH:  core\scheduler\Scheduler.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/process/Process.hpp"
#include "core/execution/CoreManager.hpp"
#include "strategies/_all.hpp"
#include "SchedulerStrategy.hpp"
#include "SchedulerData.hpp"
#include "types.hpp"


/**
 * @brief Central scheduler controller for the OS simulation.
 * 
 * Owns the strategy, configuration, interpreter, and high-level
 * orchestration of ticks and process generation.
 */
class Scheduler {
  public:

  Scheduler():
    names      (vec<str>()),            // Deferred generation vec<str> for user-inserted proc_table
    ticks      (0),                    // Global tick counter
    generating (false),                 // Flag indicating auto-generation mode
    data       (SchedulerData()),       // Internal state (cores, proc_table, vec<str>)
    strategy   (SchedulerStrategy()) {} // Contains the scheduler strategy

  /** Adds a user-named process to the pending generation vec<str>. */
  void generate_process(str name) { names.push_back(move(name)); }

  /** Enables or disables automatic process generation each tick. */
  void generate(bool flag) { generating = flag; }

  /** @brief Executes the active strategy logic and increments the tick count. */
  void tick() {
    if (!data.config.getb("initialized")) return;

    // Generate batch processes
    generate_processes();

    // Release finished or preempted cores
    release_processes();

    /** TODO: Clean/update paging info. */ 
    // memory.tick(data);

    // Tick sleeping processes
    tick_sleeping_processes();
      
    // Assign new processes to idle cores
    strategy.tick(data);
    ++ticks;
  }

  /** @brief Applies a new configuration and resizes core state accordingly. */
  void set_config(Config config) {
    strategy = get_scheduler_strategy(config.gets("scheduler"));
    data.cores.resize(config.getu("num-cpu"));                        

    // Create the preempt handler from the factory method
    auto preempt_handler = strategy.get_preempt_handler(data);
    
    // Inject in each core the preemption handler from strategy
    if (preempt_handler != nullptr)
      for (auto& ref: data.cores.get_all())                       
        ref.get().set_preempt(preempt_handler);

    data.config = move(config); // Must come last                               
  }

  // ------ Member variables ------

  vec<str> names;                
  uint ticks;             
  bool generating;    
  SchedulerData data;         
  SchedulerStrategy strategy;

  // ------ Internal logic ------

  private:

  /** @brief Helper that checks if the current tick matches the process generation interval. */
  auto interval_has_elapsed() -> bool {
    uint freq = data.config.getu("batch-process-freq");
    return freq > 0 && (ticks % freq == 0);
  }

  /** @brief Helper that generates user and scheduler-enqueued processes. */
  void generate_processes() {
    auto make_process = [&](uint pid, str name="") {
      auto pname = name.empty() ? format("p{:02}", pid) : move(name);
      auto min = data.config.getu("min-ins");
      auto max = data.config.getu("max-ins");
      auto size = Rand::num(min, max);

      data.add_process(Process(pid, move(pname), size));
      data.rqueue.push(pid);
    };

    for (auto& name: names)
      make_process(data.new_pid(), move(name));
    names.clear();

    if (generating && interval_has_elapsed())
      make_process(data.new_pid());
  }

  /** @brief Helper that releases finished or preempted processes in cores. */
  void release_processes() {
    for (auto& ref: data.cores.get_releasable()) {
      auto& core = ref.get();
      auto& process = core.get_job();
      core.release();

      if (process.data.program.finished())
        data.finished_pids.push_back(process.data.id);
      else if (process.data.control.sleeping())
        data.wqueue.push_back(process.data.id);     
      else                                      
        data.rqueue.push(process.data.id);  // Not finished, not sleeping â†’ just resume later
    }
  }

  void tick_sleeping_processes() {
    auto& wqueue = data.wqueue;
    for (auto it = wqueue.begin(); it != wqueue.end(); ) {
      auto& process = data.get_process(*it);
      process.step();             // decrement sleep_ticks

      if (!process.data.control.sleeping()) {
        data.rqueue.push(*it);    // ready again
        it = wqueue.erase(it);    // remove from wqueue
        continue;
      }

      ++it;                       // still sleeping
    }
  }
};

------------------------------
 FILE:  SchedulerData.hpp
 PATH:  core\scheduler\SchedulerData.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/process/Process.hpp"
#include "core/execution/CoreManager.hpp"
#include "types.hpp"


/**
 * @brief Encapsulates scheduling context passed to strategy functions.
 * 
 * Provides access to the current core vec<uint>, ready queue, and tick counter.
 * Also handles state reset and tick progression during simulation.
 */
class SchedulerData {  
  public:
  
  SchedulerData():
    proc_table    (map<uint,uptr<Process>>()),  // Container for all processes
    finished_pids (vec<uint>()),                // PIDs of Finished processes 
    rqueue        (queue<uint>()),              // Ready queue of processes waiting to be scheduled
    wqueue        (list<uint>()),               // Ready queue of processes waiting to be scheduled
    next_pid      (atomic_uint{1}),             // PID counter for generating unique process IDs
    config        (Config()),          // Runtime configuration settings
    cores         (CoreManager()) {}            // Owned instance of scheduler core manager

  /** @brief Returns a unique, incrementing process ID. */
  auto new_pid() -> uint { return next_pid++; }

  /** @brief Adds a process to the process table. */
  void add_process(Process proc) {
    auto id = proc.data.id;
    auto ptr = make_unique<Process>(move(proc));
    proc_table.emplace(id, move(ptr)); 
  }

  /** @brief Check if a process with the given ID exists. */
  auto has_process(uint id) -> bool { return proc_table.contains(id); }

  /** @brief Check if a process with the given name exists. */
  auto has_process(const str& name) -> bool { return !!find_process_by_name(name, false); }
  
  /** @brief Returns a reference wrapper to the process with the given PID. */
  auto get_process(uint id) -> Process& { return *proc_table.at(id); }

  /** @brief Returns a reference wrapper to the process with the given name. */
  auto get_process(const str& name) -> Process& { return *find_process_by_name(name); }
  
  /** @brief Returns the vec<uint> of running process IDs. */
  auto get_running_pids() -> vec<uint> { return cores.get_running_pids(); }

  // ------ Member variables ------

  map<uint, uptr<Process>> proc_table;
  vec<uint> finished_pids;         
  queue<uint> rqueue;                 
  list<uint> wqueue;                 
  Config config;             
  CoreManager cores;                  
  atomic_uint next_pid;           

  // ------ Internal logic ------

  private:

  /** @brief Returns a pointer to a process given a name, or throws if not found (if enabed). */
  auto find_process_by_name(const str& name, bool throw_if_missing=true) -> Process* {
    for (auto& [_, proc]: proc_table)
      if (proc->data.name == name)
        return proc.get();
  
    if (throw_if_missing)
      throw runtime_error(format("Process with name '{}' not found.", name));
    return nullptr;
  }
};

------------------------------
 FILE:  SchedulerStrategy.hpp
 PATH:  core\scheduler\SchedulerStrategy.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/execution/Core.hpp"
#include "core/scheduler/SchedulerData.hpp"

  
/**
 * @brief Represents a pluggable scheduling strategy (e.g., FCFS, RR).
 * 
 * Allows dynamic assignment of tick behavior and preemption policy.
 * Each strategy defines how proc_table are selected for execution,
 * and whether/when a running process should be preempted.
 */
class SchedulerStrategy {
  public:

  using PreemptFactory = func<Core::func(SchedulerData&)>;
  using TickHandler = func<void(SchedulerData&)>;

  SchedulerStrategy():
    name            (""s),                // Strategy identifier (e.g., "fcfs", "rr")
    tick_handler    (nullptr),            // Main strategy logic executed each tick
    preempt_factory (nullptr) {}          // Core-level preemption policy (optional)

  /** @brief Sets the strategy name. */
  auto set_name(str n) -> SchedulerStrategy& { return name = n, *this; }

  /** @brief Sets the main logic to run on each tick. */
  auto on_tick(TickHandler t) -> SchedulerStrategy& { return tick_handler = move(t), *this; }

  /** @brief Sets the per-core preemption policy. */
  auto on_preempt(PreemptFactory f) -> SchedulerStrategy& { return preempt_factory = move(f), *this;}

  /** @brief Returns a Core-level preemption lambda bound to current SchedulerData. */
  auto get_preempt_handler(SchedulerData& data) -> Core::func {
    if (!preempt_factory) return nullptr;
    return preempt_factory(data);
  }

  // === Execution ===

  /** @brief Invokes the tick handler logic on the current scheduler data. */
  void tick(SchedulerData& data) {
    if (!tick_handler)
      throw runtime_error("SchedulerStrategy::tick called without on_tick handler.");
    tick_handler(data);
  }

  // ------ Member variables ------

  str name;              
  TickHandler tick_handler;       
  PreemptFactory preempt_factory;
};

------------------------------
 FILE:  types.hpp
 PATH:  core\scheduler\types.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


/**
 * @brief Dynamic scheduler configuration using key-value pairs with std::any.
 * 
 * Supports storing any type but only str, uint, and bool are officially supported.
 */
class Config {
  public:

  Config():
    entries (ordered_map<str,any>())  // Ordered map (alphabetically) of scheduler configs
  {
    set("scheduler", "fcfs"s);
    set("num-cpu", 1u);
    set("quantum-cycles", 1u);
    set("batch-process-freq", 1u);
    set("min-ins", 1u);
    set("max-ins", 1u);
    set("delays-per-exec", 0u);
    set("initialized", false);
  }

  /** @brief Sets the value of a configuration key. */
  void set(const str& key, any value) { entries[key] = move(value); }

  /** @brief Returns true if key exists. */
  auto has(const str& key) const -> bool { return entries.contains(key); }

  // ------ Getters ------
  
  auto all() -> ordered_map<str,any>& { return entries; }

  /** @brief Retrieves the value of a key as a string. */
  auto gets(const str& key) -> str { return get<str>(key); }

  /** @brief Retrieves the value of a key as an unsigned integer. */
  auto getu(const str& key) -> uint { return get<uint>(key); }
  
  /** @brief Retrieves the value of a key as a boolean. */
  auto getb(const str& key) -> bool { return get<bool>(key); }

  // ------ Static Helpers ------

  /** @brief Parses a raw string into a typed value (bool, uint, or str). */
  static auto parse(const str& raw) -> any {
    // Lowercase copy for comparison
    auto lower = lowercase(raw);

    // Check if it's a boolean
    if (lower == "true")  return true;
    if (lower == "false") return false;

    // Check if it's a number (digits only)
    if (is_digits(raw))
      return cast<uint>(stoul(raw));

    // Default to string
    return raw;
  }

  private:

  // ------ Member variables ------
  ordered_map<str,any> entries;

  // ------ Internal helpers ------

  /** @brief Gets the value of a configuration key with expected type. */
  template <typename Type>
  auto get(const str& key) -> Type {
    if (!entries.contains(key))
      throw runtime_error(format("Missing config key '{}'", key));

    try {
      return cast<Type>(entries.at(key));

    } catch (bad_any_cast& e) {
      throw runtime_error(format("Config key '{}' has wrong type: {}", key, e.what()));
    }
  }
};

------------------------------
 FILE:  fcfs.hpp
 PATH:  core\scheduler\strategies\fcfs.hpp
------------------------------

#include "core/common/imports/_all.hpp"
#include "core/scheduler/SchedulerData.hpp"
#include "core/scheduler/SchedulerStrategy.hpp"


/**
 * Standard, Lazy, Non-Preemptive, Immediate-Arrival FCFS strategy.
 *
 * Characteristics:
 * - Non-preemptive: process runs to completion once assigned
 * - Lazy: cores pull from the queue only when idle
 * - Immediate-arrival: proc_table are enqueued as soon as they arrive
 */
auto make_fcfs_strategy() -> SchedulerStrategy {

  // Standard, Lazy, Non-Preemptive, Immediate-Arrival FCFS
  return SchedulerStrategy()
    .set_name("fcfs")

    .on_tick([](SchedulerData& data) {;
      for (auto& ref: data.cores.get_idle()) {

        // If no process is ready, stop assigning
        if (data.rqueue.empty()) break;     
        
        // Assign the selected process to the current idle core
        auto& core = ref.get();
        uint pid = data.rqueue.front(); 
        data.rqueue.pop();
        core.assign(data.get_process(pid));
      }
  });
}

------------------------------
 FILE:  rr.hpp
 PATH:  core\scheduler\strategies\rr.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/execution/Core.hpp"
#include "core/scheduler/SchedulerData.hpp"
#include "core/scheduler/SchedulerStrategy.hpp"


/**
 * Round-Robin Strategy (preemptive).
 * 
 * Characteristics:
 * - Preemptive: proc_table are interrupted after a time quantum.
 * - Immediate arrival: proc_table are placed into the ready queue directly.
 */
auto make_rr_strategy() -> SchedulerStrategy {
  return SchedulerStrategy()
    .set_name("rr")

    .on_tick([](SchedulerData& data) {
      for (auto& ref: data.cores.get_idle()) {
    
        // If no process is ready, stop assigning
        if (data.rqueue.empty()) break;
        
        auto& core = ref.get();
        uint pid = data.rqueue.front(); 
        data.rqueue.pop();
        core.assign(data.get_process(pid));
      }
    })

    .on_preempt([](SchedulerData& data) -> Core::func {
      auto quantum = data.config.getu("quantum-cycles");
      
      return [quantum](Core& core) -> bool {
        return core.job_ticks >= quantum;
      };
    });
}

------------------------------
 FILE:  _all.hpp
 PATH:  core\scheduler\strategies\_all.hpp
------------------------------

#pragma once
#include "core/scheduler/SchedulerStrategy.hpp"
#include "fcfs.hpp"
#include "rr.hpp"


auto get_scheduler_strategy(const str& name) -> SchedulerStrategy {
  if (name == "fcfs") return make_fcfs_strategy();
  if (name == "rr")   return make_rr_strategy();
  throw runtime_error(format("Unknown strategy name: {}", name));
}

------------------------------
 FILE:  Shell.hpp
 PATH:  core\shell\Shell.hpp
------------------------------

#include "internal/Shell.impl.hpp"        // Must be included first to fully define Shell
#include "core/command/handlers/_all.hpp" // Must be included after since handlers use Shell&
#include "core/common/utility/EventEmitter.hpp"

  
/**
 * @brief Populates the CommandInterpreter with all available commands.
 * 
 * Defined separately so the Shell class is fully known before
 * including handlers that use Shell&.
 */
void Shell::register_commands() {
  for (auto handler: get_command_handlers())
    interpreter.register_command(move(handler));
}

------------------------------
 FILE:  ShellScreen.hpp
 PATH:  core\shell\ShellScreen.hpp
------------------------------

#pragma once
#include "core/shell/ShellStorage.hpp"
#include "core/common/constants/banner.hpp"


class ShellScreen {  
  public:
  
  /** Initializes the screen and defaults to the main screen (ID 0). */
  ShellScreen(ShellStorage& storage): 
    storage(storage) 
  {
    storage.set("screen.id", 0u);
  }

  /** Switch to a screen by ID. Use "main" or "" for the main screen. */
  void switch_to(uint id) {
    storage.set("screen.id", id);
    if (is_main()) cout << BANNER << '\n';
  }

  /** Switch to the main screen (empty ID). */
  void switch_to_main() { switch_to(0); }

  /** Returns the screen ID string. */
  auto get_id() -> uint { return storage.get<uint>("screen.id"); }

  /** Helper: Check if screen matches an exact string (e.g. "p01") */
  auto is(uint id) -> bool { return get_id() == id; }

  /** True if current screen is the main screen. */
  auto is_main() -> bool { return get_id() == 0; }

  // ------ Member variables ------
  ShellStorage& storage;
};

------------------------------
 FILE:  ShellStorage.hpp
 PATH:  core\shell\ShellStorage.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


/** A dynamic runtime key-value store for shell commands and internal state. */
class ShellStorage {
  public:

  ShellStorage():
    storage (map<str,any>()) {}

  /** Get a reference to a stored value. Throws if key/type is incorrect. */
  template <typename Type>
  auto get(const str& key) -> Type& {
    try {
      return cast<Type&>(storage.at(key)); 
    }
    catch (const out_of_range&) {
      throw runtime_error(format("ShellStorage: Missing key '{}'", key));
    } 
    catch (const bad_any_cast&) {
      throw runtime_error(format("ShellStorage: Bad type cast for key '{}'", key));
    }
  }

  /** Set a value in shell's dynamic storage. */
  template <typename Type>
  void set(const str& key, Type value) { storage[key] = move(value); }

  /** Check if a key exists in the storage. */
  auto has(const str& key) -> bool { return storage.contains(key); }

  /** Remove a key from storage. */
  void remove(const str& key) { storage.erase(key); }

  // ------ Member variables ------
  map<str,any> storage;
};

------------------------------
 FILE:  Shell.impl.hpp
 PATH:  core\shell\internal\Shell.impl.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/common/utility/Ansi.hpp"
#include "core/common/constants/banner.hpp"
#include "core/common/utility/EventEmitter.hpp"
#include "core/command/CommandInterpreter.hpp"
#include "core/scheduler/Scheduler.hpp"

// Shell-specific includes
#include "core/shell/ShellStorage.hpp"
#include "core/shell/ShellScreen.hpp"


/** @brief Interactive shell managing CLI, events, and system ticks. */
class Shell {  
  public:

  Shell(): 
    interpreter   (CommandInterpreter::get()),  // Instance of the command interpreter
    shell_thread  (),                           // Shell thread (starts later in start())
    system_thread (),                           // Shell thread (starts later in start())
    shell_active  (atomic_bool{true}),          // Atomic flag to control shell lifecycle
    system_active (atomic_bool{true}),          // Atomic flag to control shell lifecycle
    scheduler     (Scheduler()),                // Owned scheduler instance
    storage       (ShellStorage()),             // Storage for dynamic shell/session data
    screen        (storage) {}                  // Owned instance of shell screen manager

  /** @brief Starts shell and system threads and blocks until shutdown. */
  void start() {
    initialize();
    system("cls");
    cout << '\n'; // Leave line 1 blank

    // Start shell (input) and system (scheduler) threads
    shell_thread  = Thread([&] { 
      while (shell_active)  
        tick_shell(); 
    });

    system_thread = Thread([&] { 
      while (system_active) 
        tick_system(); 
    });

    // Wait until both threads finish (safe from main thread)
    if (shell_thread.joinable())  shell_thread.join();
    if (system_thread.joinable()) system_thread.join();
    system("cls");
  }

  /** @brief Triggers shutdown. Must be called inside shell thread only. */
  void stop(bool silent=false) {
    if (!shell_active && !system_active)
      return;

    if (!silent)
      cout << "[Shell] Shutting down...\n" << flush;

    shell_active = false;
    system_active = false;
    sleep_for(300ms);       // Optional pause for effect
  }

  // ------ Member variables ------

  CommandInterpreter& interpreter;    
  Thread shell_thread;
  Thread system_thread;
  atomic_bool shell_active;
  atomic_bool system_active;
  Scheduler scheduler; 
  ShellStorage storage;
  ShellScreen screen;

  // ------ Internal helpers ------
  private:

  /** @brief Populates the CommandInterpreter with all available commands (See impl in Shell.hpp). */
  void register_commands();

  /** @brief Initializes terminal and registers all event listeners. */
  void initialize() {

    // Initialize terminal settings
    Ansi::enable();
    enable_unicode();
    
    // Initialize command handlers
    register_commands();
  }

  /** @brief Executes one shell input cycle. Called repeatedly by shell thread. */
  void tick_shell() {
    cout << ">>> " << flush;
    if (str input; getline(cin, input)) {
      with_locked([&]{
        interpreter.execute(move(input), *this);  // Executes commands
        cout << '\n';
      });

    } else {
      cout << "[Shell] Input stream closed.\n" << flush;
      stop(true);
    }
  }

  /** @brief Executes one scheduler tick. Called repeatedly by system thread. */
  void tick_system() {
    with_locked([&] {
      scheduler.tick();
    });

    sleep_for(100ms);   // Tick interval
  }
};
