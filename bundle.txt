# === GPT System Overview Request ===

You are a senior developer reviewing this project for a new team member.
Please do the following:

1. **Give an overview** of what this project does and its main components.
2. **Explain how each component works**, especially:
   - main.cpp
   - Core and CoreManager classes
   - Scheduler, SchedulerStrategy, and SchedulerData
   - Process and how it interacts with the Console and Instructions
   - Command system and Shell
3. **Describe how everything fits together** during execution:
   - How a process is created, assigned, executed, and logged.
   - How the scheduler ticks and how cores are managed.
4. **Highlight entry points** and flow of control.
5. **Note any potential issues or architecture strengths/weaknesses.**

Use the FILE: and PATH: headers to locate the content.

Please write in clear sections and simple language for onboarding a new developer.

--- End of prompt ---

------------------------------
 FILE:  main.cpp
 PATH:  main.cpp
------------------------------

#include "core/common/imports/_all.hpp"
#include "core/shell/Shell.hpp"


int main() { 
  auto shell = Shell(); // Main shell interface
  shell.start();        // Launch shell thread
}

------------------------------
 FILE:  Command.hpp
 PATH:  core\command\Command.hpp
------------------------------

#pragma once 
#include "core/common/imports/_all.hpp"


/** 
 * @brief Represents a parsed command-line input.
 * 
 * A Command encapsulates all components of a parsed input string,
 * including the command name, original argument input (excluding the command),
 * tokenized parts, positional arguments, and named flags.
 */
class Command {
  public:

  Command():
    name   (""s),           // The command name (e.g., "screen", "exit")
    input  (""s),           // Original input string after the command name
    tokens (vec<str>()),    // All space-delimited tokens after the command name
    args   (vec<str>()),    // Positional arguments for the command
    flags  (set<str>()) {}  // Set of flags (automatically deduplicated)

  // ------- Instance variables -------

  str name;
  str input;
  vec<str> tokens;
  vec<str> args;
  set<str> flags;
};

------------------------------
 FILE:  CommandHandler.hpp
 PATH:  core\command\CommandHandler.hpp
------------------------------

#pragma once 
#include "core/common/imports/_all.hpp"
#include "Command.hpp"


/** Represents a single command entry in the interpreter. */
class Shell;
class CommandHandler {
  public:

  CommandHandler():
    name     (""s),         // Command name (e.g., "screen", "exit")
    desc     (""s),         // Description for help or documentation
    min_args (0u),          // Minimum number of required arguments
    max_args (UINT_MAX),    // Maximum number of allowed arguments
    flags    (set<str>()),  // Valid flags for this command
    disabled (true),        // Commands are disabled by default
    validate (nullptr),     // Optional validation hook
    execute  (nullptr) {}   // Main handler for executing the command

  // Chainable Setters
  auto set_name(const str& value) -> CommandHandler& { return name = value, *this; }
  auto set_desc(const str& value) -> CommandHandler& { return desc = value, *this; }
  auto set_min_args(uint value) -> CommandHandler& { return min_args = value, *this; }
  auto set_max_args(uint value) -> CommandHandler& { return max_args = value, *this; }
  auto add_flag(str value) -> CommandHandler& { return flags.insert(move(value)), *this; }
  auto set_disabled(bool value) -> CommandHandler& { return disabled = value, *this; }
  auto set_validate(func<optional<str>(Command&, Shell&)> value) -> CommandHandler& { return validate = value, *this; }
  auto set_execute(func<void(Command&, Shell&)> value) -> CommandHandler& { return execute = value, *this; }
    
  // ------- Instance variables -------
  
  str name;                        
  str desc;                        
  uint min_args;                
  uint max_args;              
  set<str> flags;                       
  bool disabled;
  func<optional<str>(Command&,Shell&)> validate; 
  func<void(Command&,Shell&)> execute;
};

------------------------------
 FILE:  CommandInterpreter.hpp
 PATH:  core\command\CommandInterpreter.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "CommandHandler.hpp"
#include "CommandParser.hpp"


/**
 * @class CommandInterpreter
 * @brief Responsible for parsing, validating, and executing registered commands.
 * Acts as a central dispatcher for handling parsed input lines and invoking the appropriate command logic.
 */
class Shell;  // Forward declaration
class CommandInterpreter {
  public: 

  CommandInterpreter():
    handlers (map<str,CommandHandler>()) {} // Registry of available command handlers
  
  /** @brief Returns the global singleton get of the CommandInterpreter. */
  static CommandInterpreter& get() {
    static auto inst = CommandInterpreter();
    return inst;
  }

  /** @brief Registers a command with its name and handlers. */
  void register_command(CommandHandler handler) {
    handlers[handler.name] = move(handler);
  }

  /** @brief Executes a command in the shell context. */ 
  void execute(str& line, Shell& shell) {

    // Parse the command line into a Command (name, args, flags)
    auto command = CommandParser::parse(line);  
    if (command.name.empty()) 
      return;

    // Find command in the registry
    auto it = handlers.find(command.name);       
    if (it == handlers.end())
      return void(cout << format("[Shell] Unknown command: {}\n", command.name));

    auto& handler = it->second;

    // Check if command is disabled
    if (handler.disabled)
      return void(cout << "[Shell] This command is unavailable.\n");

    // Check for unknown/misused flags
    if (invalid_flags(command, handler))
      return void(cout << format("[Shell] Invalid or misused flag(s) for '{}'\n", command.name));

    // Check positional argument count
    if (invalid_args(command, handler))
      return void(cout << format("[Shell] Invalid number of arguments for '{}'\n", command.name));                  

    // Run optional command-specific validation logic
    if (auto msg = custom_validation(command, handler, shell))
      return void(cout << format("[Shell] {}\n", *msg));
    
    // Execute the command
    cout << '\n';
    handler.execute(command, shell);
  }

  // ------- Instance variables -------
  
  map<str,CommandHandler> handlers; 

  // ------- Internal logic -------

  private:

  /** @brief Returns true if any flag doesn't exist. */
  static auto invalid_flags(Command& command, CommandHandler& handler) -> bool {
    return any_of(command.flags, [&](const str& flag) {
      return !handler.flags.contains(flag);
    });
  }

  /** @brief Checks if argument count is within bounds. */
  static auto invalid_args(Command& command, CommandHandler& handler) -> bool {
    auto argc = command.args.size();
    return argc < handler.min_args || argc > handler.max_args;
  }

  /** Runs the handler's custom validator and returns an optional error message. */
  static auto custom_validation(Command& command, CommandHandler& handler, Shell& shell) -> optional<str> {
    if (!handler.validate) return nullopt;
    if (auto err = handler.validate(command, shell))
      return err->empty() ? "CommandHandler disabled or invalid." : *err;
    return nullopt;
  }
};

------------------------------
 FILE:  CommandParser.hpp
 PATH:  core\command\CommandParser.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/command/Command.hpp"


/**
 * @class CommandParser
 * @brief Utility class for tokenizing and parsing command lines.
 */
class CommandParser {
  public:

  /** @brief Parses a line into a Command object (name, args, flags, etc.). */
  static auto parse(str& line) -> Command {
    auto tokens = tokenize(line);
    if (tokens.empty()) return {};

    auto cmd = Command();
    cmd.name = tokens[0];

    for (auto i = 1u; i < tokens.size(); ++i) {
      auto& token = tokens[i];

      if (token.empty()) continue;  // skip empty tokens just in case
      cmd.tokens.push_back(token);  // store all meaningful tokens after name

      if (token[0] == '-')
        cmd.flags.insert(token);
      else
        cmd.args.push_back(token);
    }

    // Save input string (everything after the command name)
    auto pos = line.find_first_not_of(' ', cmd.name.size());
    cmd.input = (pos != npos) ? line.substr(pos) : "";
    return cmd;
  }

  // ------ Internal logic ------

  private:

  /** @brief Splits a line into space-delimited tokens. */
  static auto tokenize(str& line) -> vec<str> {
    if (line.empty()) return {};
    auto stream = isstream(line);
    auto tokens = vec<str>();

    for (str token; stream >> token; )
      tokens.push_back(move(token));
    return tokens;
  }
};

------------------------------
 FILE:  cls.hpp
 PATH:  core\command\handlers\cls.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_cls() -> CommandHandler {
  return CommandHandler()
    .set_name("cls")
    .set_desc("Clear screen contents.")
    .set_min_args(0)
    .set_max_args(0)
    .set_disabled(false)

    .set_validate([](Command& command, Shell& shell) -> optional<str> {
       auto config = shell.scheduler.data.config;
      if (!config.getb("initialized"))
        return "Scheduler not initialized. Please run 'initialize' first.";

      return nullopt;
    })

    .set_execute([](Command&, Shell& shell) {
      system("cls");
      cout << shell.banner.get();
    });
}


------------------------------
 FILE:  config.hpp
 PATH:  core\command\handlers\config.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_config() -> CommandHandler {
  return CommandHandler()
    .set_name("config")
    .set_desc("Displays the current scheduler configuration.")
    .set_min_args(0)
    .set_max_args(0)
    .set_disabled(false)

    .set_execute([](Command&, Shell& shell) {
      auto& config = shell.scheduler.data.config;
      cout << "â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Scheduler Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n";

      for (auto& [key, val]: config.all()) {
        auto display = ""s;

        if (val.type() == typeid(str))
          display = format("\"{}\"", cast<str>(val));
        else if (val.type() == typeid(uint))
          display = to_string(cast<uint>(val));
        else if (val.type() == typeid(bool))
          display = cast<bool>(val) ? "true" : "false";
        else
          display = "<unsupported>";

        cout << format("â”‚ {:<22} â”‚ {:<45} â”‚\n", key, display);
      }

      cout << "â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n";
    });
}

------------------------------
 FILE:  demo.hpp
 PATH:  core\command\handlers\demo.hpp
------------------------------

#pragma once
#include "core/shell/internal/Shell.impl.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionInterpreter.hpp"
#include "core/process/Process.hpp"
#include "core/process/ProcessProgram.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_demo() -> CommandHandler {
  return CommandHandler()
    .set_name("demo")
    .set_desc("Spawn and manually step a dummy FOR loop process.")
    .set_min_args(0)
    .set_max_args(0)
    .add_flag("-r")

    .set_execute([](Command& command, Shell& shell) {
      auto& interpreter = InstructionInterpreter::get();
      auto& storage = shell.storage;

      // 0. Reset process if requested
      if (command.flags.contains("-r")) {
        shell.storage.remove("demo.process");
        cout << "[demo] Dummy process reset.\n";
        return;
      }

      // 1. Spawn process if not already present
      if (!storage.has("demo.process")) {
        auto process = Process(0, "demo.process", 10);
        storage.set("demo.process", move(process));
        cout << "[demo] Process created.\n";
        return;
      }

      // 2. Access process
      auto& process = storage.get<Process>("demo.process");
      auto& program = process.data.program;

      if (program.finished())
        return void(cout << "[demo] Process already finished.");

      // === Debug: Show context stack ===
      cout << "[demo] Context Stack:\n";
      cout << program.render_context() << '\n';

      // === Debug: Show instruction list with pointer ===
      cout << "[demo] Instruction List:\n";
      cout << program.render_script() << '\n';

      // 3. Step the process
      auto done = process.step();
      cout << "[demo] Process stepped.\n";
      cout << (done ? "Finished." : "Still running.") << '\n';
    });
}

------------------------------
 FILE:  echo.hpp
 PATH:  core\command\handlers\echo.hpp
------------------------------

#pragma once
#include "core/common/utility/RichText.hpp"
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_echo() -> CommandHandler {
  return CommandHandler()
    .set_name("echo")
    .set_desc("Print arguments.")
    .add_flag("--rich")
    .set_min_args(1)
    .set_max_args(UINT_MAX)
    .set_disabled(false)

    .set_execute([](Command& command, Shell&) {
      if (!command.flags.contains("--rich"))
        cout << RichText(join(command.args)) << '\n';
      else 
        cout << join(command.args) << '\n';
    });
}

------------------------------
 FILE:  exit.hpp
 PATH:  core\command\handlers\exit.hpp
------------------------------

#pragma once
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_exit() -> CommandHandler {
  return CommandHandler()
    .set_name("exit")
    .set_desc("Exit shell.")
    .set_min_args(0)
    .set_max_args(0)
    .set_disabled(false)

    .set_execute([](Command&, Shell& shell) {
      auto& screen = shell.screen;
      if (screen.is_main())
        return void(shell.stop());

      screen.switch_to_main();
      cout << shell.banner.get();
    });
}

------------------------------
 FILE:  initialize.hpp
 PATH:  core\command\handlers\initialize.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/shell/internal/Shell.impl.hpp"
#include "core/scheduler/types.hpp"


auto make_initialize() -> CommandHandler {
  return CommandHandler()
    .set_name("initialize")
    .set_desc("Initializes the processor configuration of the application.")
    .set_min_args(0)
    .set_max_args(0)
    .set_disabled(false)

    .set_validate([](Command& command, Shell& shell) -> optional<str> {
      auto config = shell.scheduler.data.config;
      
      // Check if the scheduler has already been initialized
      if (config.getb("initialized"))
        return "Already initialized.";

      // Check if the file could not be opened or is empty
      auto lines = read_lines("config.txt");
      if (lines.empty())
        return "Failed to open config.txt";

      auto& storage = shell.storage;
      storage.set("initialize.cache", move(lines));
      return nullopt;
    })

    .set_execute([](Command& command, Shell& shell) {
      auto& storage = shell.storage;
      auto& lines = storage.get<vec<str>>("initialize.cache");
      auto config = Config();

      for (auto& line: lines) {
        str key, value;
        isstream(line) >> key >> value;
        config.set(key, Config::parse(value));
      }

      config.set("initialized", true);
      shell.scheduler.set_config(move(config));

      system("cls");
      cout << shell.banner.get();
      cout << "[Shell] Scheduler config loaded.\n";
      storage.remove("initialize.cache");

      // Enable other commands
      for (auto& [name, handler]: shell.interpreter.handlers)
        handler.set_disabled(false);
    });
}

------------------------------
 FILE:  process-smi.hpp
 PATH:  core\command\handlers\process-smi.hpp
------------------------------

#pragma once
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/shell/internal/Shell.impl.hpp"
#include "core/process/Process.hpp"
#include "core/execution/Core.hpp"


auto make_process_smi() -> CommandHandler {
  return CommandHandler()
    .set_name("process-smi")
    .set_desc("Shows the current process status, logs, and info.")
    .set_min_args(0)
    .set_max_args(0)

    .set_validate([](Command& command, Shell& shell) -> optional<str> {
      if (shell.screen.is_main())
        return "Not in a process screen.";

      auto& scheduler = shell.scheduler;
      uint pid = shell.screen.get_id();

      if (!scheduler.data.has_process(pid))
        return format("Active process with ID \"{}\" not found.", pid);

      return nullopt;
    })

    .set_execute([](Command& command, Shell& shell) {
      auto& scheduler = shell.scheduler;
      auto& storage = shell.storage;

      uint pid = shell.screen.get_id();
      auto& process = scheduler.data.get_process(pid);
      auto& program = process.data.program;

      cout << format("Process name: {}\n", process.data.name);
      cout << format("ID: {}\n", process.data.core_id);

      cout << "Logs:\n";
      for (auto& log: process.data.logs)
        cout << format("{}\n", log);

      cout << format("Current instruction line: {}\n", program.ip);
      cout << format("Lines of code: {}\n\n", program.script.size());

      shell.storage.remove("process-smi.pid");
    });
}

------------------------------
 FILE:  report-util.hpp
 PATH:  core\command\handlers\report-util.hpp
------------------------------

#pragma once
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_report_util() -> CommandHandler {
  return CommandHandler()
    .set_name("report-util")
    .set_desc("Generates a CPU unitilization report.")
    .set_min_args(0)
    .set_max_args(0)
    
    .set_validate([](Command& command, Shell& shell) -> optional<str> {
      if (!shell.screen.is_main())
        return "Not in the Main Menu.";

      auto config = shell.scheduler.data.config;
      if (!config.getb("initialized"))
        return "Scheduler not initialized. Please run 'initialize' first.";

      return nullopt;
    })

    .set_execute([](Command& command, Shell& shell) {
      auto& scheduler = shell.scheduler;
      auto& data = scheduler.data;
      auto running = data.get_running_pids();
      auto& finished = data.finished_pids;

      auto log = ofstream("csopesylog.txt");
      auto separator = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n";

      cout << format("\033[38;5;33m{}\033[0m", separator);
      log << separator;

      cout << "Running processes:\n";
      log << "Running processes:\n";

      for (auto pid: running) {
        auto& proc = data.get_process(pid);
        auto line = format(
          "  {:<10} ({})  Core: {:<2}  {} / {}\n",
          proc.data.name,
          timestamp(proc.data.stime),
          proc.data.core_id,
          proc.data.program.ip,
          proc.data.program.size()
        );
        cout << "\033[36m" << line << "\033[0m";
        log << line;
      }

      cout << "\nFinished processes:\n";
      log << "\nFinished processes:\n";

      for (auto pid: finished) {
        auto& proc = data.get_process(pid);
        auto line = format(
          "  {:<10} ({})  Finished      {} / {}\n",
          proc.data.name,
          timestamp(proc.data.stime),
          proc.data.program.size(),
          proc.data.program.size()
        );
        cout << "\033[36m" << line << "\033[0m";
        log << line;
      }

      cout << "\033[38;5;33m" << separator << "\033[0m";
      log << separator;
      log.close();

      cout << "[report-util] Report written to csopesylog.txt\n";
    });
}

------------------------------
 FILE:  scheduler-start.hpp
 PATH:  core\command\handlers\scheduler-start.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/common/utility/RichText.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/process/Process.hpp"
#include "core/shell/internal/Shell.impl.hpp"


auto make_scheduler_start() -> CommandHandler {
  return CommandHandler()
    .set_name("scheduler-start")
    .set_desc("Starts periodic dummy process generation every 'batch_process_freq' ticks.")
    .set_min_args(0)
    .set_max_args(0)
    
    .set_validate([](Command&, Shell& shell) -> optional<str> {
      auto config = shell.scheduler.data.config;

      // Check if the scheduler has already been initialized
      if (!config.getb("initialized"))
        return "Scheduler not initialized. Please run 'initialize' first.";

      if (shell.scheduler.generating)
        return "Dummy process generation already active.";

      return nullopt;
    })

    .set_execute([](Command&, Shell& shell) {
      shell.scheduler.generate(true);
      cout << RichText("\\[Shell\\] Dummy process generation [u fg=#88a17a]started[/].\n");
    });
}

------------------------------
 FILE:  scheduler-stop.hpp
 PATH:  core\command\handlers\scheduler-stop.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/common/utility/RichText.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/shell/internal/Shell.impl.hpp"


auto make_scheduler_stop() -> CommandHandler {
  return CommandHandler()
    .set_name("scheduler-stop")
    .set_desc("Stops generating dummy processes.")
    .set_min_args(0)
    .set_max_args(0)
    
    .set_validate([](Command&, Shell& shell) -> optional<str> {
      auto config = shell.scheduler.data.config;
      
      // Check if the scheduler has already been initialized
      if (!config.getb("initialized"))
        return "Scheduler not initialized. Please run 'initialize' first.";

      if (!shell.scheduler.generating)
        return "Dummy process generation is not running.";

      return nullopt;
    })
    
    .set_execute([](Command&, Shell& shell) {
      shell.scheduler.generate(false);
      cout << RichText("\\[Shell\\] Dummy process generation [u fg=#bc8f8f]stopped[/].\n");
    });
}

------------------------------
 FILE:  screen.hpp
 PATH:  core\command\handlers\screen.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/common/utility/Table.hpp"
#include "core/common/utility/Text.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/scheduler/SchedulerData.hpp"
#include "core/shell/internal/Shell.impl.hpp"

/**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Running processes:
  p04        (07/26/2025 03:49:47AM)  Core: 1   7 / 11
  p09        (07/26/2025 03:49:48AM)  Core: 2   6 / 10
  p05        (07/26/2025 03:49:47AM)  Core: 3   5 / 11
  p02        (07/26/2025 03:49:47AM)  Core: 4   4 / 7

Finished processes:
  p01        (07/26/2025 03:49:47AM)   Finished      1 / 1
  p06        (07/26/2025 03:49:47AM)   Finished      4 / 4
  p03        (07/26/2025 03:49:47AM)   Finished      5 / 5
  p07        (07/26/2025 03:49:47AM)   Finished      6 / 6
  p08        (07/26/2025 03:49:47AM)   Finished      3 / 3
  p10        (07/26/2025 03:49:48AM)   Finished      5 / 5
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 */


auto make_screen() -> CommandHandler {

  auto render_line = [](auto& process, auto state) -> str {
    auto& program = process.data.program;
    auto ip = program.ip;
    auto size = program.size();
    auto time = timestamp(process.data.stime);

    return format("  {:<10} {}   {}   {}\n",
      process.data.name,
      Text(format("({})", time))["fg33+pl"].get(),
      state,
      Text(format("{:>3} / {:<3}", ip, size))["fg208+pl"].get()
    );
  };

  auto process_exists = [](auto& name, auto& scheduler) -> bool {
    auto& data = scheduler.data;
    return data.has_process(name);
  };

  auto process_queued = [](auto& name, auto& scheduler) -> bool {
    for (uint i = 0; i < 30; ++i) {
      if (scheduler.data.has_process(name))
        return true;

      with_unlocked([&] { 
        sleep_for(200ms); 
      });
    }
    
    return false;
  };

  return CommandHandler()
    .set_name("screen")
    .set_desc("Creates and switches through existing screens.")
    .set_min_args(0)
    .set_max_args(UINT_MAX)
    .add_flag("-s")
    .add_flag("-r")
    .add_flag("-ls")
    .add_flag("-c")
    
    .set_validate([](Command& command, Shell& shell) -> optional<str> {
      auto has_ls = command.flags.contains("-ls");
      auto has_s = command.flags.contains("-s");
      auto has_r = command.flags.contains("-r");

      if (has_s + has_ls + has_r > 1)
        return "You must use only one of -s, -r, or -ls.";

      if (!shell.screen.is_main())
        return "Not in the Main Menu.";

      return nullopt;
    })

    .set_execute([&](Command& command, Shell& shell) {
      auto& screen = shell.screen;
      auto& scheduler = shell.scheduler;

      // === -ls: List screen info
      if (command.flags.contains("-ls")) {
        auto& data = scheduler.data;
        auto& cores = data.cores;

        auto size = cores.size();
        auto busy = cores.get_busy().size();
        auto cpu_util = cores.get_usage() * 100.0f;

        // Formatting
        auto line_width = 58u;
        auto blue = "fg33"s;

        cout << format("CPU Utilization: {:.2f}%\n", cpu_util);
        cout << format("Cores used: {} / {}\n\n", busy, size);
        cout << Text("â”€", line_width)[blue] << '\n';
        cout << "Running processes:\n";

        for (auto pid: cores.get_running_pids()) {
          auto& process = data.get_process(pid);
          auto core_id = process.data.core_id;
          cout << render_line(process, format("Core: {:<2}", core_id));
        }

        cout << "\nFinished processes:\n";
        for (auto pid: data.finished_pids) {
          auto& process = data.get_process(pid);
          cout << render_line(process, "Finished");
        }
        
        cout << Text("â”€", line_width)[blue];
        cout << '\n';
      }

      // === -s: Spawn and switch to new process screen
      else if (command.flags.contains("-s")) {
        
        if (command.args.empty()) 
          return void(cout << "Missing process name.\n");

        auto& name = command.args[0];
        if (process_exists(name, scheduler))
          return void(cout << format("Process '{}' already exists\n", name));

        scheduler.generate_process(name);
        cout << format("Waiting for process creation: {}", name);

        // Wait until process queues
        if (!process_queued(name, scheduler))
          return void(cout << "\nTimed out.\n");

        auto& process = scheduler.data.get_process(name);
        auto pid = process.data.id;

        screen.switch_to(pid);
        cout << '\n';
        cout << format("Process name: {}\n", process.data.name);
        cout << format("ID: {}\n", pid);

        cout << "Logs:\n";
        for (auto& log: process.data.logs)
          cout << format("  {}\n", log);

        auto& program = process.data.program;
        cout << format("Current instruction line: {}\n", program.ip);
        cout << format("Lines of code: {}\n", program.size());
      }

      // === -r: Resume process by name
      else if (command.flags.contains("-r")) {
        
        if (command.args.empty()) 
          return void(cout << "Missing process name.\n");

        auto& name = command.args[0];
        auto& data = scheduler.data;

        if (!data.has_process(name))
          return void(cout << format("Process <{}> not found.\n", name));

        auto& process = data.get_process(name);
        auto pid = process.data.id;

        screen.switch_to(pid);
        cout << format("Process name: {}\n", process.data.name);
        cout << format("ID: {}\n", pid);

        cout << "Logs:\n";
        for (auto& log: process.data.logs)
          cout << format("  {}\n", log);

        cout << format("Current instruction line: {}\n", process.data.program.ip);
        cout << format("Lines of code: {}\n", process.data.program.size());
      }

      else if (command.flags.contains("-c")) {
        /** 
         * Hi Raine! Here's the new changes:
         * 
         * @c command.input  -- raw input (without the command name)
         * @c command.tokens -- list of all args and flags in order of the input
         * @c command.flags  -- set of tokens with a dash `-` at the beginning
         * @c command.args   -- list of arguments
         * 
         */ 
      }
    });
}

------------------------------
 FILE:  util.hpp
 PATH:  core\command\handlers\util.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"
#include "core/shell/internal/Shell.impl.hpp"


auto make_util() -> CommandHandler {
  return CommandHandler()
    .set_name("report-util")
    .set_desc("Generates a report of running and Finished processes to csopesylog.txt")
    .set_min_args(0)
    .set_max_args(0)

    .set_validate([](Command&, Shell& shell) -> optional<str> {
      if (!shell.screen.is_main())
        return "Not in the Main Menu.";
      return nullopt;
    })

    .set_execute([](Command&, Shell& shell) {
      auto& data = shell.scheduler.data;
      auto running = data.cores.get_running_pids();
      auto& finished = data.finished_pids;

      auto log = ofstream("csopesylog.txt");
      auto separator = "---------------------------------------------\n";

      cout << format("\033[38;5;33m{}\033[0m", separator);
      log << separator;

      cout << "Running processes:\n";
      log << "Running processes:\n";

      for (const auto& pid : running) {
        auto& process = data.get_process(pid);
        auto line = format(
          "  {:<10} ({})  Core: {:<2}  {} / {}\n",
          process.data.name,
          timestamp(process.data.stime),
          process.data.core_id,
          process.data.program.ip,
          process.data.program.size()
        );
        cout << format("\033[36m{}\033[0m", line);
        log << line;
      }

      cout << "\nFinished processes:\n";
      log << "\nFinished processes:\n";

      for (auto& pid: finished) {
        auto& process = data.get_process(pid);
        auto line = format(
          "  {:<10} ({})  Finished      {} / {}\n",
          process.data.name,
          timestamp(process.data.stime),
          process.data.program.size(),
          process.data.program.size()
        );
        cout << format("\033[36m{}\033[0m", line);
        log << line;
      }

      cout << format("\033[38;5;33m{}\033[0m", separator);
      log << separator;
      log.close();

      cout << "[report-util] Report written to csopesylog.txt\n";
    });
}

------------------------------
 FILE:  vmstat.hpp
 PATH:  core\command\handlers\vmstat.hpp
------------------------------

#pragma once
#include "core/shell/internal/Shell.impl.hpp"
#include "core/command/Command.hpp"
#include "core/command/CommandHandler.hpp"


auto make_vmstat() -> CommandHandler {
  return CommandHandler()
    .set_name("vmstat")
    .set_desc("Provides a detailed view of the active/inactive processes, available/used memory, and pages.")
    .set_min_args(0)
    .set_max_args(0)
    
    .set_validate([](Command& command, Shell& shell) -> optional<str> {
      if (!shell.screen.is_main())
        return "Not in the Main Menu.";

      auto config = shell.scheduler.data.config;
      if (!config.getb("initialized"))
        return "Scheduler not initialized. Please run 'initialize' first.";

      return nullopt;
    })

    .set_execute([](Command& command, Shell& shell) {
      cout << "To be implemented.\n";
    });
}

------------------------------
 FILE:  _all.hpp
 PATH:  core\command\handlers\_all.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/command/CommandHandler.hpp"
#include "cls.hpp"
#include "config.hpp"
#include "demo.hpp"
#include "echo.hpp"
#include "exit.hpp"
#include "initialize.hpp"
#include "process-smi.hpp"
#include "report-util.hpp"
#include "scheduler-start.hpp"
#include "scheduler-stop.hpp"
#include "screen.hpp"
#include "vmstat.hpp"


auto get_command_handlers() -> vec<CommandHandler> {
  return {
    make_cls(),
    make_config(),
    make_demo(),
    make_echo(),
    make_exit(),
    make_initialize(),
    make_process_smi(),
    make_report_util(), 
    make_scheduler_start(),
    make_scheduler_stop(),
    make_screen(),
    make_vmstat(),
  };
}

------------------------------
 FILE:  casts.hpp
 PATH:  core\common\imports\casts.hpp
------------------------------

#pragma once
#include <any>          // for std::any, std::any_cast
#include <cstdint>      // for std::uint32_t
#include <string>       // for std::string
#include <type_traits>  // for std::decay_t
#include <utility>      // for std::forward


// Import error exceptions
using std::bad_any_cast;

// Import standard string conversion functions
using std::stoi;
using std::stof;
using std::stoul;
using std::to_string;


/** 
 * @brief Generic cast utility. 
 * Use `cast<T>(x)` freely â€” auto-selects `any_cast` or `static_cast` as needed.
 */
template <typename Target, typename Source>
auto cast(Source&& x) -> Target {
  if constexpr (std::is_same_v<std::decay_t<Source>, std::any>)
    return std::any_cast<Target>(x);
  else
    return static_cast<Target>(std::forward<Source>(x));
}

------------------------------
 FILE:  chrono.hpp
 PATH:  core\common\imports\chrono.hpp
------------------------------

#pragma once
#include <chrono>
#include <ctime>
#include <optional>


using std::chrono::duration_cast;

// Aliases for duration types
using ms  = std::chrono::milliseconds;
using ns  = std::chrono::nanoseconds;
using sec = std::chrono::seconds;

// Clock and time point
using duration = std::chrono::system_clock::duration;
using Clock = std::chrono::system_clock;
using Time = std::chrono::time_point<std::chrono::system_clock>;
using TimeStruct = std::tm;

// Literal suffixes for values like 10ms, 1s, 250ns
using std::chrono_literals::operator""ms;
using std::chrono_literals::operator""ns;
using std::chrono_literals::operator""s;

/** Returns a formatted timestamp string using current local time. */
auto timestamp(std::optional<Time> tp=std::nullopt, const std::string& fmt="%m/%d/%Y %I:%M:%S%p") -> std::string {
  auto time = Clock::to_time_t(tp.value_or(Clock::now()));
  auto time_struct = TimeStruct();
  localtime_s(&time_struct, &time);

  char buffer[32];
  strftime(buffer, sizeof(buffer), fmt.c_str(), &time_struct);
  return buffer;
}

------------------------------
 FILE:  containers.hpp
 PATH:  core\common\imports\containers.hpp
------------------------------

#pragma once
#include <deque>
#include <list>
#include <map>
#include <queue>
#include <tuple>
#include <unordered_map>
#include <set>
#include <utility>
#include <vector>

using std::deque;
using std::list;
using std::make_pair;
using std::out_of_range;
using std::pair;
using std::queue;
using std::set;
using std::tuple;
using std::unordered_map;
using std::vector;

// === Aliases ===
template <typename Type>
using vec = vector<Type>;

template <typename... Types>
using tup = tuple<Types...>;

template <typename Key, typename Val>
using ordered_map = std::map<Key, Val>;

template <typename Key, typename Val>
using map = unordered_map<Key, Val>;

------------------------------
 FILE:  helpers.hpp
 PATH:  core\common\imports\helpers.hpp
------------------------------

#pragma once
#include <cmath>
#include <cstdint>
#include <string>
#include <sstream>


// === Utility functions ===
constexpr auto count_digits(uint32_t n) -> uint32_t {
  return (n == 0) ? 1 : static_cast<int>(std::log10(n)) + 1;
}

constexpr auto pad_left(const std::string& s, uint32_t width, char fill=' ') -> std::string {
  return std::string(width > s.length() ? width - s.length() : 0, fill) + s;
}

------------------------------
 FILE:  io.hpp
 PATH:  core\common\imports\io.hpp
------------------------------

#pragma once
#include <fstream>
#include <iostream>
#include <stdexcept>
#include <string>
#include <sstream>
#include <vector>

// I/O utility aliases
using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::flush;
using std::getline;
using std::ios;
using std::ifstream;
using std::ofstream;
using std::ostream;
using std::runtime_error;


/** @brief Reads all lines from a text file into a vector of strings. */
auto read_lines(const std::string& path) -> std::vector<std::string> {
  auto file = std::ifstream(path);
  if (!file) return {};

  auto buffer = std::ostringstream();
  buffer << file.rdbuf();

  auto in = std::istringstream(buffer.str());
  auto lines = std::vector<std::string>();

  for (std::string line; std::getline(in, line); )
    lines.emplace_back(std::move(line));

  return lines;
}

------------------------------
 FILE:  iterator.hpp
 PATH:  core\common\imports\iterator.hpp
------------------------------

#pragma once
#include <iterator>   // for std::next
#include <ranges>     // for ranges algorithms
#include <algorithm>  // for std::replace, std::erase_if

// Iterator utilities
using std::next;

// Range-based algorithms
using std::ranges::all_of;
using std::ranges::any_of;
using std::ranges::count_if;
using std::ranges::find_if;
using std::ranges::none_of;
using std::ranges::replace_if;

// STL container utility
using std::erase_if;
using std::replace;

------------------------------
 FILE:  locks.hpp
 PATH:  core\common\imports\locks.hpp
------------------------------

#pragma once
#include <mutex>


/**
 * @brief Global mutex protecting all SchedulerData access.
 * 
 * This allows you to leave SchedulerData itself lock-free and instead
 * synchronize externally using a simple with_locked(...) wrapper.
 */
inline std::mutex mtx;

/**
 * @brief Executes a function with exclusive access to scheduler state.
 * 
 * This acquires a scoped lock on the global mutex, executes the
 * function, and returns its result. Automatically unlocks at scope end.
 * 
 * @tparam Func A callable type (lambda, functor, etc.)
 * @param fn The function to execute under lock
 * @return The result of the provided function (supports references and values)
 */
template <typename Func>
decltype(auto) with_locked(Func&& fn) {
  auto guard = std::lock_guard(mtx);
  return std::forward<Func>(fn)();
}

/**
 * @brief Temporarily releases the global lock to execute a function without holding it.
 * 
 * This is meant to be used **inside a with_locked section**, where the lock is
 * manually unlocked for the duration of this function and re-locked afterward.
 */
template <typename Func>
decltype(auto) with_unlocked(Func&& fn) {
  mtx.unlock();
  try {
    std::forward<Func>(fn)(); // Optional intermediate
    mtx.lock();  // re-lock before returning
  } catch (...) {
    mtx.lock();  // re-lock even if an exception is thrown
    throw;
  }
}

------------------------------
 FILE:  misc.hpp
 PATH:  core\common\imports\misc.hpp
------------------------------

#pragma once
#include <algorithm>  // required for all_of / any_of to work for some reason??
#include <any>
#include <cctype>
#include <cstdint>
#include <exception>
#include <functional>
#include <limits>
#include <optional>
#include <string>
#include <type_traits>
#include <utility>

using std::runtime_error;

// === Type Aliases ===
using std::any;
using std::exception;
using std::function;
using std::optional;
using byte = uint8_t;
using uint = uint32_t;
using uint64 = uint64_t;
using uchar = unsigned char;
using Uint = std::optional<uint>;

// === Aliases ===
template <typename Type>
using opt = optional<Type>;

template <typename... Args> 
using func = std::function<Args...>;

template <typename Type> 
using ref = std::reference_wrapper<Type>;

// === Constants ===
using std::nullopt;

// === STL Utility Aliases ===
using std::any_cast;
using std::cref;
using std::erase_if;
using std::move;
using std::forward;
using std::swap;

------------------------------
 FILE:  platform.hpp
 PATH:  core\common\imports\platform.hpp
------------------------------

#pragma once

#include <string>
#include <iostream>
#include <algorithm>

using std::min;
using std::max;
using std::string;

#if defined(_WIN32)
  #ifndef NOMINMAX
    #define NOMINMAX
  #endif
  #include <windows.h>
#else
  #include <sys/ioctl.h>
  #include <unistd.h>
  #include <locale>
  #include <cwchar>     // wcwidth
  #include <codecvt>    // std::wstring_convert
#endif


/**
 * @brief Configures the terminal for ANSI and UTF-8 output.
 *
 * On Windows, enables virtual terminal processing (ANSI escape codes)
 * and sets the output code page to UTF-8 for proper Unicode rendering.
 *
 * On Unix-like systems, disables stream synchronization for performance,
 * sets the global locale to the user's environment, and enables wide string output.
 *
 * Call this once at startup before any styled or Unicode terminal output.
 */
void initialize_terminal() {
  #if defined(_WIN32)
    // Enable ANSI escape sequences
    auto h = GetStdHandle(STD_OUTPUT_HANDLE);
    auto mode = DWORD(0);
    if (GetConsoleMode(h, &mode)) {
      mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
      SetConsoleMode(h, mode);
    }

    // Enable UTF-8 output
    SetConsoleOutputCP(CP_UTF8);
  #else
    std::ios_base::sync_with_stdio(false);
    std::setlocale(LC_ALL, "");
    std::wcout.imbue(std::locale(""));
  #endif
}

/**
 * @brief Returns the current terminal width in columns.
 *
 * Uses platform-specific system calls to detect the width of the terminal window.
 * Falls back to 80 columns if the query fails.
 *
 * @return Number of columns in the terminal (default: 80 if unknown).
 */
auto get_terminal_width() -> uint32_t {
  #if defined(_WIN32)
    auto csbi = CONSOLE_SCREEN_BUFFER_INFO{};
    if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi))
      return csbi.srWindow.Right - csbi.srWindow.Left + 1;
  #else
    struct winsize w;
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) == 0)
      return w.ws_col;
  #endif
    return 80; // fallback
}

/**
 * @brief Calculates the visual width of a UTF-8 string in terminal columns.
 *
 * Converts the string to wide characters and estimates the number of columns it will occupy,
 * accounting for fullwidth Unicode characters (e.g., CJK, symbols).
 *
 * On Windows, uses `MultiByteToWideChar` and manual width rules.
 * On Unix, uses `wcwidth` with locale awareness.
 *
 * @param utf8 A UTF-8 encoded string.
 * @return Number of display columns the string visually occupies.
 */
auto len(const std::string& utf8) -> int {
  #if defined(_WIN32)
    // Convert UTF-8 â†’ UTF-16 wide string
    int wlen = MultiByteToWideChar(CP_UTF8, 0, utf8.c_str(), -1, nullptr, 0);
    if (wlen <= 0) return 0;

    auto wstr = std::wstring(wlen, L'\0');
    MultiByteToWideChar(CP_UTF8, 0, utf8.c_str(), -1, &wstr[0], wlen);

    // Estimate width
    int width = 0;
    for (wchar_t wc : wstr) {
      if (wc == L'\0') break;
      if (wc < 32 || (wc >= 0x7f && wc <= 0x9f)) continue;
      width += (wc >= 0x1100 && (
        wc <= 0x115f ||                   // Hangul Jamo
        wc == 0x2329 || wc == 0x232a ||   // Angle brackets
        (wc >= 0x2e80 && wc <= 0xa4cf) || // CJK, Kana, Yi
        (wc >= 0xac00 && wc <= 0xd7a3) || // Hangul syllables
        (wc >= 0xf900 && wc <= 0xfaff) || // CJK Compatibility
        (wc >= 0xfe10 && wc <= 0xfe19) || // Vertical forms
        (wc >= 0xff01 && wc <= 0xff60) || // Fullwidth ASCII
        (wc >= 0xffe0 && wc <= 0xffe6)))  // Fullwidth symbols
        ? 2 : 1;
    }
    return width;
  #else
    // Use locale-aware wcwidth
    auto conv = std::wstring_convert<std::codecvt_utf8<wchar_t>>{};
    auto wstr = conv.from_bytes(utf8);

    auto width = 0;
    for (wchar_t wc : wstr) {
      int w = wcwidth(wc);
      width += (w >= 0) ? w : 0;
    }
    return width;
  #endif
}

------------------------------
 FILE:  pointers.hpp
 PATH:  core\common\imports\pointers.hpp
------------------------------

#pragma once
#include <memory>


using std::make_unique;
using std::make_shared;

// === Aliases ===

template <typename Type>
using uptr = std::unique_ptr<Type>;


------------------------------
 FILE:  random.hpp
 PATH:  core\common\imports\random.hpp
------------------------------

#pragma once
#include <algorithm>
#include <cstdlib>
#include <ctime>
#include <random>
#include <stdexcept>
#include "casts.hpp"
#include "containers.hpp"
#include "misc.hpp"


/** Random utility class */
class Rand {
  using mt19937   = std::mt19937;
  using int_dist  = std::uniform_int_distribution<>;
  using uint_dist = std::uniform_int_distribution<unsigned>;
  using real_dist = std::uniform_real_distribution<float>;

  inline static mt19937 rng = mt19937(std::random_device{}());

public:

  /** Random signed integer in [min, max] */
  static int num(int min, int max) {
    auto dist = int_dist(min, max);
    return dist(rng);
  }

  /** Random unsigned integer in [min, max] */
  static auto num(uint min, uint max) -> uint {
    auto dist = uint_dist(min, max);
    return dist(rng);
  }

  /** Returns true with probability 1/odds */
  static auto chance(uint odds) -> bool {
    return odds != 0 && num(1u, odds) == 1u;
  }

  /** Random float in [min, max) */
  static auto real(float min, float max) -> float {
    auto dist = real_dist(min, max);
    return dist(rng);
  }

  /** Pick a Random element from a non-empty vector */
  template <typename Type>
  static auto pick(Type&& list) -> decltype(auto) {
    if (list.empty())
      throw runtime_error("Cannot pick from empty list.");
    return std::forward<Type>(list)[num(0, static_cast<int>(list.size()) - 1)];
  }

  /** Shuffle a vector in place */
  template <typename Type>
  static auto shuffle(std::vector<Type>& list) -> std::vector<Type>& {
    std::shuffle(list.begin(), list.end(), rng);
    return list;
  }
};

------------------------------
 FILE:  regex.hpp
 PATH:  core\common\imports\regex.hpp
------------------------------

#pragma once
#include <regex>


using std::regex;
using std::smatch;
using std::regex_search;
using std::regex_replace;

------------------------------
 FILE:  string.hpp
 PATH:  core\common\imports\string.hpp
------------------------------

#pragma once
#include <algorithm>  // needed for all_of to work for some reason??
#include <cctype>
#include <charconv>
#include <format>
#include <string>
#include <sstream>
#include <optional>
#include <ranges>


// === String Aliases ===
using std::string;
using str = std::string;
using std::literals::string_literals::operator""s;

// === Utilities ===
using std::isalpha;
using std::isalnum;

// === Stream Aliases ===
using std::stringstream;
using std::istringstream;
using std::ostringstream;
using sstream = std::stringstream;
using isstream = std::istringstream;
using osstream = std::ostringstream;

// === Formatting & Parsing ===
using std::errc;
using std::format;
using std::from_chars;

// === Constants ===
constexpr auto npos = string::npos;

// === Validation ===

/** @brief Returns true if the string consists only of digit characters (0â€“9). */
auto is_digits(const std::string& s) -> bool {
  return !s.empty() && std::ranges::all_of(s, [](char c) {
    return std::isdigit(static_cast<unsigned char>(c));
  });
}

// === Utility functions ===

/** @brief Returns a lowercase copy of the given string. */
auto lowercase(str raw) -> str {
  for (char& c: raw)
    c = tolower(c);
  return raw;
}

/** @brief Joins a vector of strings using the given delimiter. */
auto join(vec<str>& args, char delim=' ') -> str {
  if (args.empty()) return "";
  
  auto oss = osstream();
  oss << args[0];
  for (auto i = 1u; i < args.size(); ++i)
    oss << delim << args[i];
  return oss.str();
}

/** @brief Returns a copy of the string with leading and trailing whitespace removed. */
auto trim(const str& s) -> str {
  auto start = s.find_first_not_of(" \t\n\r");
  if (start == npos) return "";  // all whitespace
  auto end = s.find_last_not_of(" \t\n\r");
  return s.substr(start, end - start + 1);
};

------------------------------
 FILE:  thread.hpp
 PATH:  core\common\imports\thread.hpp
------------------------------

#pragma once
#include <atomic>
#include <condition_variable>
#include <mutex>
#include <shared_mutex>
#include <thread>


// === Atomic Types ===
using std::atomic;
using std::atomic_bool;
using std::atomic_int;
using std::atomic_uint;
using std::atomic_bool;

// === Locking & Threading Aliases ===
using std::lock_guard;
using std::mutex;
using std::shared_lock;
using std::shared_mutex;
using std::this_thread::sleep_for;
using std::unique_lock;
using Thread = std::thread;

------------------------------
 FILE:  _all.hpp
 PATH:  core\common\imports\_all.hpp
------------------------------

#pragma once
#include "locks.hpp"
#include "casts.hpp"
#include "chrono.hpp"
#include "containers.hpp"
#include "helpers.hpp"
#include "io.hpp"
#include "iterator.hpp"
#include "misc.hpp"
#include "platform.hpp"
#include "pointers.hpp"
#include "random.hpp"
#include "regex.hpp"
#include "string.hpp"
#include "thread.hpp"

------------------------------
 FILE:  Ansi.hpp
 PATH:  core\common\utility\Ansi.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


class Ansi {

  public:

  static void enable() {
    auto handle = GetStdHandle(STD_OUTPUT_HANDLE);
    auto mode = DWORD(0);
    
    if (!GetConsoleMode(handle, &mode))
      return void(cerr << "Failed to get console mode.\n");

    mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
    if (!SetConsoleMode(handle, mode)) 
      return void(cerr << "Failed to enable ANSI escape sequences.\n");
  }
  
  static void set_title(ostream& out, const str& title) {
    out << "\033]0;" << title << "\a";
  }

  static void enter_alt_buffer(ostream& out) {
    out << "\033[?1049h";
  }

  static void exit_alt_buffer(ostream& out) {
    out << "\033[?1049l";
  }

  static void hide_cursor(ostream& out) {
    out << "\033[?25l";
  }

  static void show_cursor(ostream& out) {
    out << "\033[?25h";
  }

  static void clear_screen(ostream& out) {
    out << "\033[2J\033[H";
  }

  static void move_cursor(ostream& out, int row, int col) {
    out << "\033[" << row << ";" << col << "H";
  }
};

------------------------------
 FILE:  RichText.hpp
 PATH:  core\common\utility\RichText.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


class StyleStack {
  public:

  StyleStack():
    stack(vec<pair<str,str>>()) {}  // Start with an empty list of style layers

  /** @brief Add all styles (as separate layers) to the stack. */
  void push(map<str,str> styles) {
    for (auto& [key, val]: styles)
      stack.emplace_back(move(key), move(val));
  }

  /** @brief Remove the most recent layer containing a given style tag. */
  void pop(str tag) {
    for (auto rit = stack.rbegin(); rit != stack.rend(); ++rit) {
      if (rit->first != tag)
        continue;

      auto it = next(rit).base();  // convert to forward iterator
      stack.erase(it);
      break;
    }
  }

  /** @brief Clear all styles from the stack. */
  void reset() { 
    stack.clear(); 
    stack.shrink_to_fit();
  }

  /** @brief Combine all active styles into one map. */
  auto get_styles() -> map<str,str> {
    auto result = map<str,str>();

    for (auto& [key, val]: stack)
      result[key] = val;
    return result;
  }

  // ------ Instance variables ------
  vec<pair<str, str>> stack;
};


class RichText {
  public:

  // ------ Class variables ------
  static inline auto TAG_PATTERN = regex(R"(\[(/?)([^\[\]]*?)\])");
  static inline auto ESC_LB      = regex(R"(\\\[)");
  static inline auto ESC_RB      = regex(R"(\\\])");
  static inline auto PLACE_LB    = "\x01";
  static inline auto PLACE_RB    = "\x02";
  static inline auto ANSI_RESET  = "\033[0m";

  static inline auto STYLES = map<str,str>{
    {"bold",      "1"}, 
    {"dim",       "2"}, 
    {"italic",    "3"},
    {"underline", "4"}, 
    {"strike",    "9"},
  };

  static inline auto COLORS = map<str,str>{
    {"black",     "#000000"}, 
    {"red",       "#ff0000"}, 
    {"green",     "#00ff00"},
    {"yellow",    "#ffff00"}, 
    {"blue",      "#0000ff"}, 
    {"magenta",   "#ff00ff"},
    {"cyan",      "#00ffff"}, 
    {"white",     "#ffffff"}, 
    {"gray",      "#808080"},
    {"lightgray", "#cccccc"}, 
    {"darkred",   "#880000"},
    {"darkgreen", "#008800"}, 
    {"darkblue",  "#000088"},
  };

  static inline auto ALIASES = map<str,str>{
    {"b", "bold"}, 
    {"i", "italic"}, 
    {"u", "underline"},
    {"s", "strike"}, 
    {"d", "dim"},
  };

  RichText(str input):
    raw   (move(input)),  // Store the raw input string with markup tags
    text  (""s),          // Initialize rendered ANSI-formatted text (to be set by render())
    size  (0u),           // Number of visible characters (excluding ANSI codes)
    stack (StyleStack())  // Initialize the style stack for nested formatting
  {
    text = render();                // Immediately render text
    size = strip_ansi(text).size(); // Only count visible characters
  }
  
  /** @brief Enables ANSI and Unicode output (once at startup). */
  static void enable() {
    initialize_terminal();
  }

  /** @brief Streams the rendered text to an output stream (e.g., std::cout). */
  friend ostream& operator<<(ostream& os, const RichText& rt) {
    return os << rt.text;
  }

  // ------ Instance variables ------
  
  str raw;
  str text;
  uint size;
  StyleStack stack;

  // ------ Internal helpers ------

  private:

  /** @brief Removes ANSI escape codes from the given string. */
  auto strip_ansi(str& text) -> str {
    static auto ansi_re = regex(R"(\x1B\[[0-9;]*m)");
    return regex_replace(text, ansi_re, "");
  }

  /** @brief Converts a hex color string or named color to an RGB tuple. */
  auto hex_to_rgb(str value) -> tuple<uint,uint,uint> {
    value.erase(0, 1); // remove leading #
    auto r = stoul(value.substr(0, 2), nullptr, 16);
    auto g = stoul(value.substr(2, 2), nullptr, 16);
    auto b = stoul(value.substr(4, 2), nullptr, 16);
    return { r, g, b };
  }

  auto is_valid_hex_color(const str& value) -> bool {
    return value.size() == 7
      && value[0] == '#'
      && all_of(value.begin()+1, value.end(), ::isxdigit);
  }

  /** @brief Converts a style map to an ANSI escape code string. */
  auto to_ansi(const map<str,str>& styles) -> str {
    auto codes = vec<str>();

    for (auto& [key, value]: styles) {
      if (STYLES.contains(key)) {
        codes.push_back(STYLES.at(key));

      } else if (key == "fg") {
        auto hex = COLORS.contains(value) ? COLORS.at(value) : value;
        if (!is_valid_hex_color(hex)) continue; // skip if not valid hex color

        auto [r, g, b] = hex_to_rgb(hex);
        codes.push_back(format("38;2;{};{};{}", r, g, b));

      } else if (key == "bg") {
        auto hex = COLORS.contains(value) ? COLORS.at(value) : value;
        if (!is_valid_hex_color(hex)) continue; // skip if not valid hex color
        
        auto [r, g, b] = hex_to_rgb(hex);
        codes.push_back(format("48;2;{};{};{}", r, g, b));
      }
    }

    return codes.empty() ? "" : format("\033[{}m", join(codes, ';'));
  }

  auto resolve_tag(str& tag) -> str {
    return ALIASES.contains(tag) ? ALIASES.at(tag) : tag;
  }

  auto parse_to_styles(str& tag) -> map<str,str> {
    auto result = map<str,str>();
    auto stream = isstream(tag);
    auto token = ""s;

    while (stream >> token) {
      auto eq = token.find('=');
      
      if (eq == npos) {
        auto key = resolve_tag(token);
        result[key] = "";   // Flag tag with no value ([bold] becomes {"bold": "-"})
        continue;
      }

      auto key = token.substr(0, eq);
      auto val = token.substr(eq+1);
      key = resolve_tag(key);
      result[key] = val;
    }

    return result;
  }

  auto render() -> str {
    auto out = ""s;
    auto index = 0u;

    // Escape literal brackets (\[ and \]) so they are not parsed as tags
    auto text = regex_replace(raw, ESC_LB, PLACE_LB);
    text = regex_replace(text, ESC_RB, PLACE_RB);

    auto match = smatch();
    while (regex_search(text.cbegin() + index, text.cend(), match, TAG_PATTERN)) {
      out += text.substr(index, match.position());  // Add all plain text before the tag

      auto is_closing = match[1].str() == "/";
      auto tag = trim(match[2].str());  // raw tag content

      if (is_closing) {           // Handle [/], which resets all styles
        if (tag.empty()) {                          
          stack.reset();
          out += ANSI_RESET;
        
        } else {                  // Handle [/<tag>] - pop specific style
          stack.pop(resolve_tag(tag));
          out += ANSI_RESET + to_ansi(stack.get_styles());
        }

      } else {                    // Handle [tag ...] â€” parse and push new style(s)
        stack.push(parse_to_styles(tag));
        out += to_ansi(stack.get_styles());
      }

      index += match.position() + match.length();  // Move index forward to just after the matched tag
    }

    // Append remaining raw text and unescape any \[ or \]
    out += text.substr(index);
    replace(out.begin(), out.end(), *PLACE_LB, '[');
    replace(out.begin(), out.end(), *PLACE_RB, ']');


    // Only append reset if styling was ever applied
    if (!stack.get_styles().empty())
      out += ANSI_RESET;

    stack.reset();  // To free memory once text has been rendered
    return out;
  }
};


// int main() {
//   auto t1 = RichText("Hello [b]World[/b]");
//   auto t2 = RichText("[i]Italic[/i] text");
//   auto t3 = RichText("[u]Underlined[/u] content");
//   auto t4 = RichText("[strike]Struck[/strike] out");
//   auto t5 = RichText("Mix: [b]Bold[/] then [i]Italic[/] and [u]Underline[/]");
//   auto t6 = RichText("Color test: [fg=red]Red[/fg], [fg=#00ff00]Green[/fg]");
//   auto t7 = RichText("Background test: [bg=yellow]Yellow Background[/bg]");
//   auto t8 = RichText("[b fg=blue]Bold Blue [fg=green]Green[/fg] Back to Blue[/b]");
//   auto t9 = RichText("Escaped: \\[b\\]not bold\\[/b\\]");
//   auto t10 = RichText("[b fg=red]Red Bold[/] Normal");
//   auto t11 = RichText("[b]123[/]456");

//   cout << "Test 1:  " << t1 << "\n";
//   cout << "Test 2:  " << t2 << "\n";
//   cout << "Test 3:  " << t3 << "\n";
//   cout << "Test 4:  " << t4 << "\n";
//   cout << "Test 5:  " << t5 << "\n";
//   cout << "Test 6:  " << t6 << "\n";
//   cout << "Test 7:  " << t7 << "\n";
//   cout << "Test 8:  " << t8 << "\n";
//   cout << "Test 9:  " << t9 << "\n";
//   cout << "Test 10: " << t10 << "\n";
//   cout << "Test 11: " << t11 << " (size = " << t11.size << ")\n";
//   return 0;
// }

------------------------------
 FILE:  Table.hpp
 PATH:  core\common\utility\Table.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/common/utility/Text.hpp"


/** @brief Simple ASCII-style table renderer with box borders and left-aligned rows. */
class Table {
  public:

  /** @brief Constructs a table with a specified total width. */
  Table(uint width): 
    width (width),        // Total width of the table including borders
    rows  (vec<str>()) {} // Accumulated rendered rows

  /** @brief Adds the top border using Unicode rounded corners. */
  auto head() -> Table& {
    auto line = Text("â”€", width - 2).get();
    rows.push_back(format("â•­{}â•®", line));
    return *this;
  }

  /** @brief Adds a middle horizontal bar with T-shaped corners. */
  auto bar() -> Table& {
    auto line = Text("â”€", width - 2).get();
    rows.push_back(format("â”œ{}â”¤", line));
    return *this;
  }

  /** @brief Adds the bottom border using Unicode rounded corners. */
  auto dbar() -> Table& {
    auto line = Text("â”€", width - 2).get();
    rows.push_back(format("â•°{}â•¯", line));
    return *this;
  }

  /** @brief Adds a left-aligned row of content, padded and clamped to fit. */
  auto row(const str& content) -> Table& {
    auto visual = len(content);
    auto padded = visual >= width - 4
      ? content.substr(0, width - 4)
      : content + str(width - 4 - visual, ' ');

    rows.push_back(format("â”‚ {} â”‚", padded));
    return *this;
  }

  /** @brief Inserts one or more blank rows (default: 1 line). */
  auto gap(uint count = 1) -> Table& {
    auto empty = str(width - 4, ' ');
    for (uint i = 0; i < count; ++i)
      rows.push_back(format("â”‚ {} â”‚", empty));
    return *this;
  }

  /** @brief Joins all rows into a single string. */
  auto get() const -> str {
    auto out = osstream();
    for (auto& r : rows) 
      out << r << '\n';
    return out.str();
  }

  /** @brief Prints the table using `cout << table`. */
  friend auto operator<<(ostream& out, const Table& t) -> ostream& {
    return out << t.get();
  }

  private:

  // ------ Instance variables ------
  
  uint width;       
  vec<str> rows;    

  // ------ Internal helpers ------
  /** @brief Returns visual length of a string, excluding ANSI escape sequences. */
  auto len(const str& s) -> uint {
    auto visual = 0u;
    auto in_ansi = false;

    for (char c: s) {
      if (c == '\033') { in_ansi = true; continue; }
      if (in_ansi) {
        if (c == 'm') in_ansi = false;
        continue;
      }
      ++visual;
    }

    return visual;
  }
};

------------------------------
 FILE:  Text.hpp
 PATH:  core\common\utility\Text.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


/** @brief Handles foreground and background ANSI color codes. */
class TextColor {
  public:

  TextColor():
    fg (-1),   // Default: no foreground color set
    bg (-1) {} // Default: no background color set

  auto set_fg(uint code) -> TextColor& { fg = code; return *this; }
  auto set_bg(uint code) -> TextColor& { bg = code; return *this; }

  /** 
   * @brief Applies ANSI color codes to the input text.
   * @example 
   *   TextColor().set_fg(196).set_bg(15).use("Error");
   *   // â†’ "\033[38;5;196m\033[48;5;15mError\033[0m"
   */
  auto to(const str& text) const -> str {
    auto out = ""s;
    if (fg >= 0) out += format("\033[38;5;{}m", fg);
    if (bg >= 0) out += format("\033[48;5;{}m", bg);
    return format("{}{}\033[0m", out, text);
  }

  // ------ Instance variables -------
  int fg;
  int bg;
};


/** @brief Handles bold, italic, underline, reverse styles. */
class TextStyle {
  public:

  TextStyle():
    bold      (false),    // Bold style (ANSI \033[1m)
    italic    (false),    // Italic style (ANSI \033[3m)
    underline (false),    // Underline style (ANSI \033[4m)
    reverse   (false) {}  // Reverse video (ANSI \033[7m)

  auto set_bold() -> TextStyle& { return bold = true, *this; }
  auto set_italic() -> TextStyle& { return italic = true, *this; }
  auto set_underline() -> TextStyle& { return underline = true, *this; }
  auto set_reverse() -> TextStyle& { return reverse = true, *this; }

  /** 
   * @brief Returns the text with ANSI style codes applied.
   * @example
   *   TextStyle().set_bold(true).set_italic(true).to("Hello");
   *   // â†’ "\033[1m\033[3mHello"
   */
  auto to(const str& text) const -> str {
    auto out = ""s;
    if (bold)      out += "\033[1m";
    if (italic)    out += "\033[3m";
    if (underline) out += "\033[4m";
    if (reverse)   out += "\033[7m";
    return out + text;
  }

  // ------ Instance variables -------
  bool bold;
  bool italic;
  bool underline;
  bool reverse;
};


/** @brief Handles padding and alignment. */
class TextAlign {
  public:

  TextAlign():
    align ('l'),    // Alignment: 'l' = left, 'c' = center, 'r' = right
    fill  (' ') {}  // Padding fill character (default: space)

  auto set_align(char a) -> TextAlign& { return align = a, *this; }
  auto set_fill(char f) -> TextAlign& { return fill = f, *this; }

  /** 
   * @brief Applies alignment using current terminal width.
   * @example TextAlign().set_align('c').set_fill('.').to("Hello");
   */
  auto to(const str& input) const -> str {
    uint width = get_terminal_width();

    if (width <= len(input))
      return input;

    uint pad = width - len(input);
    if (align == 'r')
      return str(pad, fill) + input; // default right
      
    else if (align == 'c') {
      uint lpad = pad / 2;
      uint rpad = pad - lpad;
      return str(lpad, fill) + input + str(rpad, fill);
    }
      
      return input; // default left
  }

  // ------ Instance variables -------
  char align;
  char fill;
};


/** @brief Main class to represent styled, padded terminal text. */
class Text {
  public:

  Text(const str& s, uint count=1): 
    raw(rep(s, count)), // Original input text
    color(),            // Handles foreground and background colors
    style(),            // Handles text styles (bold, italic, etc.)
    align() {}          // Handles alignment and padding

  /** @brief Enables ANSI and Unicode output (once at startup). */
  static void enable() {
    initialize_terminal();
  }

  /** @brief Returns the fully formatted output string. */
  auto get() const -> str {
    auto padded = align.to(raw);
    auto styled = style.to(padded);
    return color.to(styled);
  }

  /** @brief Applies style/color/padding using a style string. */
  auto use(const str& spec) -> Text& {
    auto stream = isstream(spec);
    auto token = ""s;

    while (getline(stream, token, '+')) {
      // Text style tokens
      if (token == "b") style.set_bold();
      else if (token == "i") style.set_italic();
      else if (token == "u") style.set_underline();
      else if (token == "rev") style.set_reverse();

      // Named foreground colors
      else if (token == "r")  color.set_fg(196);
      else if (token == "gr") color.set_fg(46);
      else if (token == "yl") color.set_fg(226);
      else if (token == "bl") color.set_fg(27);
      else if (token == "mg") color.set_fg(201);
      else if (token == "cy") color.set_fg(51);
      else if (token == "wh") color.set_fg(15);

      // 256-color support
      else if (token.starts_with("fg")) color.set_fg(stoul(token.substr(2)));
      else if (token.starts_with("bg")) color.set_bg(stoul(token.substr(2)));

      else if (token == "pl") align.set_align('l');
      else if (token == "pc") align.set_align('c');
      else if (token == "pr") align.set_align('r');
      else if (token.starts_with("pf") && token.length() == 3)
        align.set_fill(token[2]);
    }

    return *this;
  }

  /** @brief Alternate way to apply DSL: Text("x")["gr+b+p10c"] */
  auto operator[](const str& spec) -> Text {
    auto copy = *this;
    return copy.use(spec);
  }

  /** @brief Enables usage with std::ostream (e.g. `cout << text`) */
  friend auto operator<<(ostream& out, const Text& t) -> ostream& {
    return out << t.get();
  }

  private:

  // ------ Instance variables ------

  str raw;
  TextColor color;
  TextStyle style;
  TextAlign align;  

  // ------ Internal helpers ------

  /** @brief Repeats a string `count` times efficiently. */
  static auto rep(const str& s, uint count) -> str {
    if (count == 0) return "";
    if (count == 1) return s;

    auto out = ""s;
    out.reserve(s.size() * count);
    for (uint i = 0; i < count; ++i)
      out += s;
    return out;
  }
};

------------------------------
 FILE:  Core.hpp
 PATH:  core\execution\Core.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/process/Process.hpp"


/**
 * @brief Represents a passive simulated CPU core that ticks independently in a thread.
 * 
 * Responsibilities:
 * - Continuously ticks in its own thread every 1ms to simulate real-time execution.
 * - Executes (`step()`) the currently assigned process one instruction per tick.
 * - Monitors its assigned process for completion or preemption conditions.
 * - Sets `can_release = true` to signal readiness for job release.
 * 
 * Key Behaviors:
 * - Does **not** assign or release proc_table â€” only the **Scheduler** can do that.
 * - Ignores ticking if no process is assigned (`job == nullptr`) or if marked `can_release`.
 * - Calls a user-provided preemption handler, if any, to check for early release.
 * - Tracks how long a job has been running via `job_ticks`.
 * 
 * Design Notes:
 * - Core runs **faster** than the scheduler (1ms tick vs. ~100ms scheduler tick).
 * - Implements `assign()` and `release()` methods, but only for use by the scheduler.
 * - Internally manages its own thread and guarantees safe shutdown in destructor.
 * - Tick behavior is guarded to avoid dereferencing null process pointers.
 * - Cannot crash from invalid job access â€” fully guarded and thread-safe by design.
 */
class Core {
  public:
  using func = func<bool(Core&)>;

  /** @brief Constructs a core with the given ID and starts the thread. */
  Core(uint id=0): 
    id          (id),                 // Core ID
    job_ticks   (0u),                 // Number of ticks the current process has been running
    delay       (0u),                 // Target delay per instruction (delay_per_exec)
    can_release (false),              // Whether the process is eligible for release by the Scheduler
    job         (nullptr),            // Pointer to the currently assigned process (if any)
    preempt     (nullptr),            // For injecting a preemption handler (optional).
    active      (atomic_bool{true}),  // Atomic flag for tick loop, mark the core as active/busy
    thread      ()                    // Background ticking thread
  { 
    // Launch the background thread that ticks continuously
    thread = Thread([this] { 
      auto counter = 0u;

      while (active) {
        if (counter-- == 0) {
          with_locked([&] { tick(); });
          counter = delay;
        }
        sleep_for(1ms);  // always happens
      }
    });
  }

  /** @brief Destructor stops the tick thread cleanly. */
  ~Core() { stop(); }

  /** @brief Initializes core with a given delay and optional preemp handler. */
  void init(uint ticks, func handler=nullptr) {
    delay = ticks;
    preempt = handler;
  }

  /** @brief Called by scheduller to assign a process to this core. */
  void assign(Process& process) { set_job(&process, id); }

  /** @brief Called only by the scheduler to release the current job. */
  void release() { if (job) set_job(nullptr); }

  /** @brief Returns true no process is assigned to the core. */
  auto is_idle() -> bool { return job == nullptr; }

  /** @brief Returns the currently assigned job. */
  auto get_job() -> Process& {
    if (job) return *job;
    throw runtime_error("Core::get_job: No job is currently assigned");
  } 

  // ------ Instance variables ------

  uint id;                      
  uint job_ticks;       
  uint delay;       
  bool can_release;   
  Process* job; 
  func preempt;    
  atomic_bool active;   
  Thread thread; 

  // ------ Internal logic ------

  private:

  /** @brief Performs one CPU tick: steps the assigned process if valid. */
  void tick() {
    if (job == nullptr) return; // If no process is assigned to this core, skip the tick
    if (can_release) return;    // Prevent ticking the process if it's already marked for release

    try {
      auto& process = *job;       // Get the process from the process pointer
      process.step();             // Execute one instruction from the process script
      ++job_ticks;

      // If the process has finished all its instructions, mark for release
      if (job->data.program.finished())
        can_release = true;

      // Mark release if process is sleeping
      else if (process.data.control.sleeping()) // COMMENT OUT IF SLEEPING DOESN'T PREEMPT A PROCESS
        can_release = true;

      // If the process has finished all its instructions, mark for release
      else if (preempt && preempt(*this))
        can_release = true;

    } catch (exception& e) {
      cerr << format("[Core {}] tick(): Exception: {}\n", id, e.what());
      throw;
    }
  }

  /** @brief Signals the core to stop and joins the thread cleanly. */
  void stop() {
    active = false;             // Signals the thread to stop
    if (thread.joinable())      // Only joins if the thread is valid
      thread.join();            // Waits for the thread to finish
  }

  // ------ Helper methods ------

  /** @brief Assigns or clears the process currently running on this core. */
  void set_job(Process* process, int core_id=-1) {
    if (process != nullptr)     // Assigning a new process? Mark it with this core's ID
      process->data.core_id = core_id;
    
    job = process;              // Update process pointer slot (null if releasing)
    job_ticks = 0;              // Reset job tick counter â€” either a new job or clearing old one
    can_release = false;        // Always reset release flag; only tick() will set it to true when appropriate
  }    
};

------------------------------
 FILE:  CoreManager.hpp
 PATH:  core\execution\CoreManager.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/execution/Core.hpp"


/**
 * @brief Manages the pool of Core components for the scheduler system.
 * 
 * Responsibilities:
 * - Owns and maintains all simulated CPU cores as `Core` objects.
 * - Provides safe and filtered access to all, busy, or idle cores.
 * - Handles core lifecycle: creation, reset, and safe iteration.
 * 
 * Key Behaviors:
 * - `init(size)`: Replaces all cores with a new set of N fresh cores.
 * - `get_busy()` / `get_idle()`: Filters out cores by status for use in scheduling logic.
 * - `get_usage()`: Returns a float utilization ratio (busy / total cores).
 * - `get_running_pids()` and `get_busy_core_ids()`: Extract diagnostic metadata from active cores.
 * 
 * Design Notes:
 * - vec<uptr<Core>> are stored as `uptr<Core>` to ensure clean ownership and destruction.
 * - Always use reference-returning accessors (`vec<ref<Core>>`) instead of raw pointer access.
 * - Guards against null pointers even though `init()` always populates all slots.
 * - Scheduler is the only component expected to use this class directly.
 */
class CoreManager {
  public:

  CoreManager():
    cores (vec<uptr<Core>>()) {}  // Vector contianer for cores

  /** @brief Clears and initializes the core list with the specified number of cores */
  void init(uint size) {
    cores.clear();        // Destroys all existing cores (just in case)
    cores.reserve(size);  // Preallocate to avoid reallocations
    for (auto i=0u; i < size; ++i)
      cores.emplace_back(make_unique<Core>(i+1));
  }

  /** @brief Returns number of cores. */
  auto size() -> uint { return cores.size(); }
  
  /** @brief Returns the current CPU core utilization as a float [0.0, 1.0]. */
  auto get_usage() -> float {
    return cores.empty() ? 0.f : float(get_busy_size()) / float(cores.size());
  }

  /** @brief Access a specific core by index. */
  auto get(uint i) -> Core& { return *cores.at(i); }

  /** @brief Returns references to all cores. */
  auto get_all() -> vec<ref<Core>> { return filter_cores([](auto& ptr) { return true; }); }

  /** @brief Returns a list of references to all idle cores. */
  auto get_idle() -> vec<ref<Core>> { return filter_cores([](auto& ptr) { return ptr->is_idle(); }); }

  /** @brief Returns a list of references to all busy (non-idle) cores. */
  auto get_busy() -> vec<ref<Core>> { return filter_cores([](auto& ptr) { return !ptr->is_idle(); }); }
  
  /** @brief Returns the number of currently busy (non-idle) cores. */
  auto get_busy_size() -> uint {
    return count_if(cores, [](auto& ptr) { return ptr != nullptr && !ptr->is_idle(); });
  }

  /** @brief Returns a list of references to all busy (non-idle) and releasable  cores. */
  auto get_releasable() -> vec<ref<Core>> { return filter_cores([](auto& ptr) { return !ptr->is_idle() && ptr->can_release; }); }

  /** @brief @brief Returns a list of IDs for all busy (non-idle) cores. */
  auto get_busy_core_ids() -> vec<uint> { return extract_ids([](auto& core) { return core.id; }); }

  /** @brief Returns a list of pids to all busy (non-idle) cores. */
  auto get_running_pids() -> vec<uint> { return extract_ids([](auto& core) { return core.get_job().data.id; }); }

  // ------ Internal logic ------

  private:

  // ------ Instance variables ------
  vec<uptr<Core>> cores;

  // ------ Helper Methods ------

  /** @brief Returns references to cores that satisfy the given filter condition. */
  template <typename Func = bool(*)(uptr<Core>&)>
  auto filter_cores(Func func) -> vec<ref<Core>> {
    auto result = vec<ref<Core>>();     // Create a list of core reference wrappers
    result.reserve(cores.size());       // Optional: preallocate to avoid reallocations

    for (auto& ptr: cores)
      if (ptr != nullptr && func(ptr))  // Only include non-null cores that pass the filter
        result.push_back(ref(*ptr));    // Store a reference wrapper of the matching core
    
    return result;
  }

  /** @brief Extracts a list of uint values from all busy cores using the given accessor. */
  template <typename Func = bool(*)(Core&)>
  auto extract_ids(Func func) -> vec<uint> {
    auto busy = get_busy();             // Store once to reuse
    auto result = vec<uint>();
    result.reserve(busy.size());        // Reserve exactly what we need

    for (auto& ref: busy)
      result.push_back(func(ref.get()));

    return result;
  }
};

------------------------------
 FILE:  Instruction.hpp
 PATH:  core\instruction\Instruction.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


/** Represents a single process instruction. */
struct Instruction {
  str opcode;     // Operation name, e.g., `FOR`, `PRINT`, etc.
  vec<str> args;  // List of string arguments

  /**
   * Metadata: cached exit address for control-flow blocks, e.g., `FOR`, `IF`.
   * Set dynamically to allow skipping. A value of 0 means unset.
   */
  uint exit = 0;
};

------------------------------
 FILE:  InstructionHandler.hpp
 PATH:  core\instruction\InstructionHandler.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "Instruction.hpp"
#include "types.hpp"

class ProcessData; // Forward declaration

/** Represents an executable instruction handler. */
class InstructionHandler {
  public:

  InstructionHandler():
    opcode      (""s),              // The opcode string representing the instruction.
    open_opcode (""s),              // For control instruction with a matching open
    exit_opcode (""s),              // For control instruction with a matching exit
    signatures  (vec<Signature>()), // Describes expected argument types
    execute     (nullptr) {}        // Function to execute the instruction
    
  // Chainable setters
  
  /** @brief Sets the opcode for this instruction. */
  auto set_opcode(str op) -> InstructionHandler { return opcode = move(op), *this; }

  /** @brief Sets the matching open opcode (used by control exit instructions). */
  auto set_open(str op) -> InstructionHandler { return open_opcode = move(op), *this; }
  
  /** @brief Sets the matching exit opcode (used by control open instructions). */
  auto set_exit(str op) -> InstructionHandler { return exit_opcode = move(op), *this; }
  
  /** @brief Adds a signature definition to the instruction. */
  auto add_signature(Signature sig) -> InstructionHandler { return signatures.push_back(move(sig)), *this; }
  
  /** @brief Sets the execution function for this instruction. */
  auto set_execute(func<void(Instruction&,ProcessData&)> fn) -> InstructionHandler { return execute = move(fn), *this; }

  /** @brief Returns true if this instruction begins a open control block (e.g., FOR). */
  auto is_control_open() -> bool { return !exit_opcode.empty(); }

  /** @brief Returns true if this instruction begins a exit control block (e.g., FOR). */
  auto is_control_exit() -> bool { return !open_opcode.empty(); }

  /** @brief Generates a random instruction based on the signature. */
  auto generate() -> Instruction {
    auto inst = Instruction(opcode);
    if (signatures.empty()) return inst;

    auto& sig = Rand::pick(signatures);
    inst.args = sig.generate();
    return inst;
  }

  // ------ Instance variables ------

  str opcode;                                     
  str open_opcode;                                
  str exit_opcode;                                
  vec<Signature> signatures;    
  func<void(Instruction&,ProcessData&)> execute;  
};

------------------------------
 FILE:  InstructionInterpreter.hpp
 PATH:  core\instruction\InstructionInterpreter.hpp
------------------------------

#pragma once
#include "core/instruction/handlers/_all.hpp"
#include "core/process/ProcessData.hpp"
#include "InstructionHandler.hpp"
#include "Instruction.hpp"


/** Central registry and dispatcher for all instruction types. */
class InstructionInterpreter {
  private:
  
  /** 
   * Private constructor to enforce singleton access via get().
   * Initializes and registers all handlers once. 
   */
  InstructionInterpreter():
    handlers         (map<str,InstructionHandler>()),   // opcode -> handler
    all_handlers     (vec<ref<InstructionHandler>>()),  // cached reference list for introspection
    flat_handlers    (vec<ref<InstructionHandler>>()),  // Handlers for non-control instructions
    control_handlers (vec<ref<InstructionHandler>>())   // Handlers for control instructions
  {
    for (auto& inst: get_instruction_handlers())
      register_instruction(move(inst));

    // Categorize and cache handler references for quick lookup
    all_handlers.reserve(handlers.size());

    for (auto& [_, handler]: handlers) {
      all_handlers.push_back(ref(handler));  // Add to full list

      // Separate into control vs. flat based on metadata
      if (handler.is_control_exit()) continue;
      if (handler.is_control_open())
        control_handlers.push_back(ref(handler));
      else
        flat_handlers.push_back(ref(handler));
    }
  }

  public:

  /** @brief Returns the global singleton get of the InstructionInterpreter. */
  static auto get() -> InstructionInterpreter& {
    static auto inst = InstructionInterpreter();
    return inst;
  }

  /** @brief Registers a handler by opcode. */
  void register_instruction(InstructionHandler handler) {
    handlers[handler.opcode] = move(handler);
  }

  /** @brief Execute an instruction using its handler. */
  void execute(Instruction& inst, ProcessData& proc) {
    auto it = handlers.find(inst.opcode);
    if (it == handlers.end())
      throw runtime_error("Unknown instruction: " + inst.opcode);

    it->second.execute(inst, proc);
  }

  /** @brief Generates a random list of up to `size` instructions with proper block closure. */
  auto generate_script(uint size, uint max_depth=3) -> vec<Instruction> {
    auto script = vec<Instruction>();
    auto stack = vec<ref<InstructionHandler>>();                      // Tracks opened control blocks
    auto inst_count = [&]() { return script.size() + stack.size(); }; // actual + pending ENDFORS

    while (inst_count() < size) {
      if (should_open(stack, max_depth) && inst_count()+2 <= size)    // For opening control instructions
        open_control_block(script, stack);
      
      else if (should_close(stack))                       // For closing control instructions
        close_control_block(script, stack);

      if (!flat_handlers.empty() && inst_count() < size)  // For adding flat instructions
        script.push_back(Rand::pick(flat_handlers).get().generate());
    }

    // Auto-close any unclosed control blocks
    while (!stack.empty())
      close_control_block(script, stack);

    return script;
  }

  // ------ Instance variables ------

  map<str,InstructionHandler> handlers;           
  vec<ref<InstructionHandler>> all_handlers;      
  vec<ref<InstructionHandler>> flat_handlers;     
  vec<ref<InstructionHandler>> control_handlers;

  // ------ Internal helpers ------

  /** @brief Returns true if a control block can be opened (depth-limited, random chance). */
  bool should_open(vec<ref<InstructionHandler>>& stack, uint max_depth) { 
    return !control_handlers.empty() && (stack.size() < max_depth) && Rand::chance(4); 
  }

  /** @brief Returns true if a control block can be closed (if any open, random chance). */
  bool should_close(vec<ref<InstructionHandler>>& stack) { 
    return !stack.empty() && Rand::chance(4); 
  }

  /** @brief Emits a random control-opener instruction and pushes it to the stack. */
  void open_control_block(vec<Instruction>& script, vec<ref<InstructionHandler>>& stack) {
    auto& handler = Rand::pick(control_handlers);
    script.push_back(handler.get().generate());
    stack.push_back(handler);
  }

  /** @brief Emits the matching end-opcode of the current open control block. */
  void close_control_block(vec<Instruction>& script, vec<ref<InstructionHandler>>& stack) {
    if (stack.empty())
      throw runtime_error("Attempted to emit ENDFOR with empty control stack!");
    
    auto& opener = stack.back();
    script.emplace_back(opener.get().exit_opcode);
    stack.pop_back();
  }
};

------------------------------
 FILE:  types.hpp
 PATH:  core\instruction\types.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


/** @brief Represents one argument in an instruction signature. */
class Arg {
  public:

  Arg(str type, uint min=0, uint max=0): 
    type (move(type)),  // Parameter type: "str", "uint", or "var"
    min  (min),         // Minimum value (for "uint" type)
    max  (max) {}       // Maximum value (for "uint" type)
  
  // ------ Instance variables ------
  str type; 
  uint min; 
  uint max; 
};

/** @brief Builder for defining and generating argument signatures for instructions. */
class Signature {
  public:

  Signature(): 
    args(vec<Arg>()) {}   // Initializes an empty signature

  // === Builders ===

  /** @brief Adds a string argument. */
  auto Str() -> Signature& { return add("str"); }

  /** @brief Adds a variable name argument. */
  auto Var() -> Signature& { return add("var"); }

  /** @brief Adds an unsigned integer argument. */
  auto Uint(uint min, uint max) -> Signature& { return add("uint", min, max); }

  /** @brief Adds an unsigned 8-bit integer argument (0â€“255). */
  auto Uint8() -> Signature& { return Uint(0, 255); }

  /** @brief Adds an unsigned 16-bit integer argument (0â€“65535). */
  auto Uint16() -> Signature& { return Uint(0, 65535); }

  // === Accessors ===

  /** @brief Returns the full list of argument specs. */
  auto get() -> vec<Arg>& { return args; }

  /** @brief Returns the number of arguments in the signature. */
  auto size() -> uint { return args.size(); }

  // === Generator (optional utility) ===

  /** @brief Generates a list of example argument values matching the signature. */
  auto generate() -> vector<str> {
    auto result = vector<str>();
    for (auto& arg: args) {
      if (arg.type == "uint")     result.push_back(to_string(Rand::num(arg.min, arg.max)));
      else if (arg.type == "str") result.push_back(Rand::pick(messages));
      else if (arg.type == "var") result.push_back(Rand::pick(vars));
      else                        result.push_back("<?>");
    }
    return result;
  }

  private:

  // ------ Instance variables ------
  vec<Arg> args;

  // ------ Constants ------
  inline static  auto messages = vec<str>{ "hello", "world", "lorem", "ipsum", "test" };
  inline static  auto vars = vec<str>{ "x", "y", "z" };

  // ------ Internal Helpers ------
  
  /** @brief Adds a generic argument of given type and optional bounds. */
  auto add(str type, uint min=0, uint max=0) -> Signature& { 
    return args.emplace_back(move(type), min, max), *this; 
  }
};

------------------------------
 FILE:  add.hpp
 PATH:  core\instruction\handlers\add.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/process/ProcessData.hpp"


auto make_add() -> InstructionHandler {
  return InstructionHandler()
    .set_opcode("ADD")
    .add_signature(Signature().Var().Var().Var())
    .add_signature(Signature().Var().Var().Uint16())
    .add_signature(Signature().Var().Uint16().Uint16())

    .set_execute([](Instruction& inst, ProcessData& process) {
      auto& memory = process.memory;
      auto lhs = memory.get(inst.args[1]);
      auto rhs = memory.resolve(inst.args[2]);
      memory.set(inst.args[0], lhs + rhs);
    });
}

------------------------------
 FILE:  declare.hpp
 PATH:  core\instruction\handlers\declare.hpp
------------------------------

#pragma once
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/process/ProcessData.hpp"


auto make_declare() -> InstructionHandler {
  return InstructionHandler()
    .set_opcode("DECLARE")
    .add_signature(Signature().Var().Uint16())
    .set_execute([](Instruction& inst, ProcessData& process) {
      auto var = inst.args[0];
      auto value = stoul(inst.args[1]);
      process.memory.set(var, value);
    });
}

------------------------------
 FILE:  endfor.hpp
 PATH:  core\instruction\handlers\endfor.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/process/ProcessData.hpp"


auto make_endfor() -> InstructionHandler {
  return InstructionHandler()
    .set_opcode("ENDFOR")
    .set_open("FOR")

    .set_execute([](Instruction& inst, ProcessData& process) {
      auto& program = process.program;
      auto& context = program.context;
      auto& frame = context.top();
      auto& frame_inst = program.script.at(frame.ip);

      // Check if block is inside a FOR loop
      if (frame_inst.opcode != "FOR")
        throw runtime_error("[ENDFOR] No matching FOR block on stack.");

      // Cache exit address if it's not set
      if (inst.exit == 0)
        inst.exit = program.ip + 1;

      // Decrement loop count; jump back if more iterations remain
      if (--frame.ctr > 0)
        return void(program.set_ip(frame.ip));

      context.pop();
    });
}

------------------------------
 FILE:  for.hpp
 PATH:  core\instruction\handlers\for.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/instruction/types.hpp"
#include "core/process/ProcessData.hpp"


auto make_for() -> InstructionHandler {
  
  // === Skips ahead to the matching ENDFOR. ===
  auto skip_block = [](auto& program, auto& inst) { 

    // Use cached exit if available
    if (inst.exit != 0)
      return void(program.set_ip(inst.exit));
      
    auto& script = program.script;
    auto start = program.ip;
    auto depth = 1u;

    // Otherwise, scan ahead to find the matching ENDFOR
    for (auto i = start+1u; i < script.size(); ++i) {
      auto& opcode = script[i].opcode;
      int delta = (opcode == "FOR") - (opcode == "ENDFOR");
      depth += delta;
      
      // If matching ENDFOR is found, cache exit address and exit loop
      if (depth == 0) {
        inst.exit = i + 1;
        program.set_ip(inst.exit);
        return;
      }
    }
    
    throw runtime_error("[FOR] Mismatched FOR/ENDFOR blocks.");
  };

  return InstructionHandler()
    .set_opcode("FOR")
    .set_exit("ENDFOR")
    .add_signature(Signature().Uint(1,5))

    .set_execute([&](Instruction& inst, ProcessData& process) {
      auto& program = process.program;
      auto count = stoul(inst.args[0]);

      // Skip if counter is 0
      if (count == 0)
        return skip_block(program, inst);

      auto& context = program.context;
      if (!context.top_ip_is(program.ip))
        context.push(program.ip, count);
    });
}

------------------------------
 FILE:  print.hpp
 PATH:  core\instruction\handlers\print.hpp
------------------------------

#pragma once
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/instruction/types.hpp"
#include "core/process/ProcessData.hpp"


auto make_print() -> InstructionHandler {
  return InstructionHandler()
    .set_opcode("PRINT")
    .add_signature(Signature().Str())
    .add_signature(Signature().Str().Var())
    
    .set_execute([](Instruction& inst, ProcessData& process) {
      process.log(inst.args[0]);
    });
}

------------------------------
 FILE:  sleep.hpp
 PATH:  core\instruction\handlers\sleep.hpp
------------------------------

#pragma once
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/process/ProcessData.hpp"


auto make_sleep() -> InstructionHandler {
  return InstructionHandler()
    .set_opcode("SLEEP")
    .add_signature(Signature().Uint(0,3))

    .set_execute([](Instruction& inst, ProcessData& process) {
      auto ticks = stoul(inst.args[0]);

      // Case 0: Skip sleep if duration is zero
      if (ticks == 0)
        return;

      auto& program = process.program;
      auto& control = process.control;

      // Case 1: Begin or continue sleeping
      if (!control.sleeping())
        control.sleep_for(ticks);
      else 
        control.tick();

      // Case 2: Still sleeping
      if (control.sleeping())
        program.set_ip(program.ip);  // Block auto-increment
    });
}

------------------------------
 FILE:  subtract.hpp
 PATH:  core\instruction\handlers\subtract.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionHandler.hpp"
#include "core/process/ProcessData.hpp"


auto make_subtract() -> InstructionHandler {
  return InstructionHandler()
    .set_opcode("SUBTRACT")
    .add_signature(Signature().Var().Var().Var())
    .add_signature(Signature().Var().Var().Uint16())
    .add_signature(Signature().Var().Uint16().Uint16())

    .set_execute([](Instruction& inst, ProcessData& process) {
      auto& memory = process.memory;
      auto lhs = memory.get(inst.args[1]);
      auto rhs = memory.resolve(inst.args[2]);
      memory.set(inst.args[0], lhs > rhs ? lhs - rhs : 0);
    });
}

------------------------------
 FILE:  _all.hpp
 PATH:  core\instruction\handlers\_all.hpp
------------------------------

#pragma once
#include "core/instruction/InstructionHandler.hpp"
#include "add.hpp"
#include "declare.hpp"
#include "endfor.hpp"
#include "for.hpp"
#include "print.hpp"
#include "sleep.hpp"
#include "subtract.hpp"


auto get_instruction_handlers() -> vec<InstructionHandler> {
  return {
    make_add(),
    make_declare(),
    make_endfor(),
    make_for(),
    make_print(),
    make_sleep(),
    make_subtract(),
  };
}

------------------------------
 FILE:  main.py
 PATH:  core\memory\main.py
------------------------------

from MemoryManager2 import *


class Process:
    def __init__(self, pid, manager):
        vmemory = manager.get_vmemory(pid)
        self.memory = ProcessMemory(vmemory)


class CommandRegistry:
    def __init__(self, mm: MemoryManager, process: Process):
        self.mm = mm
        self.process = process
        self.commands = {
            "write": self._write,
            "read": self._read,
            "declare": self._declare,
            "add": self._add,
            "vmstat": self._vmstat,
            "process-smi": self._process_smi,
            "write-raw": self._write_raw,
        }

    def execute(self, line):
        tokens = line.strip().split()
        if not tokens: return
        cmd, args = tokens[0], tokens[1:]

        if cmd not in self.commands:
            print(f"[shell] Unknown command: {cmd}")
            return

        try:
            self.commands[cmd](args)
        except Exception as e:
            print(f"[error] {e}")

    # Command Handlers

    def _write_raw(self, args):
        if len(args) != 2:
            print("[write-raw] Usage: write-raw <vaddr> <value>")
            return

        vaddr = int(args[0])
        value = int(args[1])
        print(f"[exec] WRITE-RAW vaddr={hex(vaddr)} = {value}")

        is_violation, is_page_fault = self.process.memory.view.write(vaddr, value)
        if is_violation:
            print("[write-raw] Invalid address (violation)")
        elif is_page_fault:
            print("[write-raw] Page fault occurred â€” retry later")
        else:
            print("[write-raw] Write successful")

    def _write(self, args):
        var, value = args[0], int(args[1])
        print(f"[exec] WRITE {var} = {value}")
        success = self.process.memory.set(var, value)
        if not success:
            print("[write] Page fault occurred â€” retry later")

    def _read(self, args):
        var = args[0]
        print(f"[exec] READ {var}")
        value, is_violation, is_page_fault = self.process.memory.get(var)

        if is_violation:
            print(f"[read] '{var}' is undeclared â€” cannot read")
        elif is_page_fault:
            print("[read] Page fault occurred â€” retry later")

    def _declare(self, args):
        if len(args) != 2:
            print("[declare] Usage: declare <var> <value>")
            return

        var, value = args[0], int(args[1])
        print(f"[exec] DECLARE {var} = {value}")
        success = self.process.memory.set(var, value)
        if not success:
            print(f"[declare] Page fault occurred during declaration â€” retry later")

    def _add(self, args):
        if len(args) != 3:
            print("[add] Usage: add <dst> <src1> <src2>")
            return
        dst, src1, src2 = args
        print(f"[exec] ADD {dst} {src1} {src2}")

        val1, inv1, pf1 = self.process.memory.get(src1)
        val2, inv2, pf2 = self.process.memory.get(src2)

        if inv1 or inv2:
            print("[add] One or more variables undeclared â€” aborting")
            return
        if pf1 or pf2:
            print("[add] Page fault occurred â€” retry later")
            return

        result = (val1 + val2) & 0xFFFF
        success = self.process.memory.set(dst, result)
        if not success:
            print("[add] Destination write page fault â€” retry later")

    def _vmstat(self, args):
        if not args:
            print("[vmstat] Usage: vmstat <pid>")
            return

        pid = int(args[0])
        if pid not in self.mm.data.page_table_map:
            print(f"[vmstat] No page table found for pid={pid}")
            return

        print(f"[vmstat] Process {pid}:")
        table = self.mm.data.page_table_map[pid]
        for page_num in sorted(table.pages()):
            entry = table.get(page_num)
            if entry.is_loaded():
                print(f"  Page {page_num:<2} â†’ Frame {entry.frame_num}")
            else:
                print(f"  Page {page_num:<2} â†’ Not Loaded")

    def _process_smi(self, args):
        mm = self.mm
        print("=== PROCESS-SMI: Memory Summary ===")
        print(f"Total frames:     {mm.data.frame_count}")
        print(f"Free frames:      {len(mm.data.free_frames)}")
        print(f"Used frames:      {mm.data.frame_count - len(mm.data.free_frames)}\n")

        for pid, page_table in mm.data.page_table_map.items():
            print(f"Process PID: {pid}")
            loaded = 0
            for page_num in sorted(page_table.pages()):
                page = page_table.get(page_num)
                if page.is_loaded():
                    print(f"  Page {page_num:02} â†’ Frame {page.frame_num}")
                    loaded += 1
                else:
                    print(f"  Page {page_num:02} â†’ Not loaded")
            print(f"  Total pages: {len(page_table.pages())}, Loaded: {loaded}")
            print()


if __name__ == "__main__":
    mm = MemoryManager()
    mm.init(capacity=64, page_size=64)
    mm.alloc(pid=1, bytes_needed=128)        # 2 pages
    process = Process(pid=1, manager=mm)
    registry = CommandRegistry(mm, process)

    registry.execute("write-raw 0 111")      ; print()  # page 0 â†’ frame 0
    registry.execute("write-raw 64 222")     ; print()  # page 1 â†’ frame 0
    registry.execute("write-raw 0 333")      ; print()  # will fail naturally


------------------------------
 FILE:  MemoryManager.hpp
 PATH:  core\memory\MemoryManager.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "MemoryManagerData.hpp"
#include "MemoryView.hpp"
#include "types.hpp"


class MemoryManager {
  public:

  MemoryManager():
    data (MemoryManagerData()) {}

  void init(uint capacity, uint page_size) {    
    data.page_size = page_size;
    data.frame_count = capacity / page_size;
    data.memory = vec<uint>(capacity, 0);
  
    // Reset and repopulate the free frame list
    data.free_frames.clear(); 
    for (auto i=0u; i < data.frame_count; ++i)
      data.free_frames.push_back(i);

    // Clear all process page tables
    data.page_table_map.clear();
  }

  auto alloc(uint pid, uint bytes_needed) -> bool {
    auto pages_needed = (bytes_needed + data.page_size - 1) / data.page_size;
    auto page_table = PageTable();

    for (auto page_num=0; page_num < pages_needed; ++page_num)
      page_table.add(page_num, PageEntry());

    data.page_table_map[pid] = move(page_table);
    return true;
  }

  auto create_memory_view_for(uint pid) -> MemoryView {
    return MemoryView(pid, data, [this](uint pid, uint page_num) {
      return this->page_in(pid, page_num);
    });
  }

  // ------ Member variables ------
  MemoryManagerData data;
  
  // ------ Internal helpers ------
  private:

  /** Fills the given frame in memory using the provided filler function. */
  void fill_frame(uint frame_num, func<uint(uint)> filler) {
    auto maddr = frame_num * data.page_size;
    for (auto i = 0u; i < data.page_size; ++i)
      data.memory[maddr + i] = filler(i);
  }

  /**
   * Loads the given virtual page into memory for a process.
   * May evict another page if no free frame is available (side effect).
   */
  auto page_in(uint pid, uint page_num) -> bool {
    auto& free_frames = data.free_frames;
    auto frame_num = opt<uint>();
    
    // Try to get a free frame
    if (!data.free_frames.empty()) {
      frame_num = free_frames.front();
      free_frames.pop_front();
    } 
    // Try to evict a page
    else
      frame_num = page_out(); // <- side effect

    // Failed to allocate a frame (no evictable page)  
    if (!frame_num)
      return false;

    // Fetch page table and page metadata
    auto& table = data.page_table_map[pid];
    auto& page = table.get(page_num);

    // Assign physical frame to page
    page.frame_num = frame_num;
    data.equeue.push_back({ pid, page_num });

    // Fill frame with content from backing store or zero-fill
    auto key = make_key(pid, page_num);
    if (data.store.contains(key)) {
      auto bytes = move(data.store.at(key));
      data.store.erase(key);
      fill_frame(*frame_num, [&](uint i) { return bytes[i]; });
    }
    else
      fill_frame(*frame_num, [](uint) { return 0; });

    return true;
  }

  /**
    * Evicts one loaded page from memory and returns its freed frame number.
    * This simulates basic page replacement when memory is full.
    * Also known as: "evict_page".
    */
  auto page_out() -> opt<uint> {
    while (!data.equeue.empty()) {
      auto [pid, page_num] = data.equeue.front();
      data.equeue.pop_front();   

      auto& table = data.page_table_map[pid];
      auto& page = table.get(page_num);

      auto frame_num = page.frame();
      page.frame_num = nullopt;
      data.free_frames.push_back(frame_num);

      auto maddr = frame_num * data.page_size;
      auto start = data.memory.begin() + maddr;
      auto end = start + data.page_size;
      auto bytes_out = vec<uint>(start, end);
      data.store[make_key(pid, page_num)] = move(bytes_out);
      return frame_num;
    }
    return nullopt;
  }

  /**
   * Computes a unique 64-bit key for a process-page pair.
   * Used as the backing store index for evicted pages.
   */
  auto make_key(uint pid, uint page_num) -> uint64 {
    return (cast<uint64>(pid) << 32) | page_num;
  }
};

------------------------------
 FILE:  MemoryManager.py
 PATH:  core\memory\MemoryManager.py
------------------------------

class PageEntry:
    """
    Represents the metadata of a virtual page (not the actual content).

    This object tracks:
      - which physical frame it's loaded in (if any)
      - whether the page is currently loaded into memory

    Note:
        This does NOT contain the page's data. Content is stored in the
        memory array (RAM) and/or the backing store.
    """

    def __init__(self, frame_num=None):
        self.frame_num = frame_num   # Physical frame index (or None if not loaded)

    def is_loaded(self):
        """True if page is currently loaded in memory (i.e. mapped to a frame)."""
        return self.frame_num is not None


class PageTable:
    def __init__(self):
        self.entries = {}  # Maps virtual page number â†’ PageEntry

    def has_page(self, page_num):
        return page_num in self.entries

    def get(self, page_num):
        return self.entries[page_num]

    def add(self, page_num, page):
        self.entries[page_num] = page

    def pages(self):
        return self.entries.keys()

    def mark_unloaded(self, page_num):
        self.entries[page_num].frame_num = None

    def is_loaded(self, page_num):
        return self.entries[page_num].is_loaded()

    def get_frame(self, page_num):
        return self.entries[page_num].frame_num


class MemoryManager:
    def __init__(self):
        # Config and memory state
        self.page_size = 0          # Bytes per page/frame
        self.frame_count = 0        # Total number of frames

        self.memory = []            # Physical memory: flat list of bytes
        self.free_frames = []       # Tracks available frame indices
        self.page_table_map = {}    # Page tables: maps pid â†’ PageTable object
        self.equeue = []            # Tracks (pid, page_num) in load order
        self.store = {}             # Backing store: (pid, page_num) â†’ byte array

    def init(self, capacity, page_size):
        """Initialize the memory manager with total capacity and page size."""
        self.page_size = page_size
        self.frame_count = capacity // page_size
        self.memory = [0] * capacity
        self.free_frames = list(range(self.frame_count))
        self.page_table_map.clear()

    def alloc(self, pid, bytes_needed):
        """
        Reserves virtual pages for a process without loading them.
        Pages are created but not assigned frames until accessed.

        Args:
            pid (int): Process ID.
            bytes_needed (int): Bytes to alloc.

        Returns:
            bool: True if allocation succeeded.
        """
        pages_needed = (bytes_needed + self.page_size - 1) // self.page_size
        page_table = PageTable()
        for page_num in range(pages_needed):
            page_table.add(page_num, PageEntry())
        self.page_table_map[pid] = page_table
        return True

    def write(self, pid, vaddr, value):
        """Write a 2-byte value at the virtual address of a process."""
        if not self._owns_vaddr(pid, vaddr, num_bytes=2):
            raise Exception(f"Access violation (WRITE) at address {hex(vaddr)}")
        maddr1 = self._maddr_of(pid, vaddr)
        maddr2 = self._maddr_of(pid, vaddr + 1)
        self.memory[maddr1] = value & 0xFF
        self.memory[maddr2] = (value >> 8) & 0xFF

    def read(self, pid, vaddr):
        """Read a 2-byte value at the virtual address of a process."""
        if not self._owns_vaddr(pid, vaddr, num_bytes=2):
            raise Exception(f"Access violation (READ) at address {hex(vaddr)}")
        maddr1 = self._maddr_of(pid, vaddr)
        maddr2 = self._maddr_of(pid, vaddr + 1)
        lo = self.memory[maddr1]
        hi = self.memory[maddr2] << 8
        return lo | hi

    # ------ PRIVATE METHODS ------

    def _owns_vaddr(self, pid, vaddr, num_bytes=1):
        """
        Checks whether a range of virtual addresses is allocated to the given process.
        Validates that [addr, addr + bytes - 1] fits entirely within
        the set of reserved pages (regardless of load state).

        Args:
            pid (int): Process ID.
            addr (int): Starting virtual address.
            bytes (int): Number of bytes to check (default: 1).

        Returns:
            bool: True if all pages in range are reserved by the process.
        """
        if pid not in self.page_table_map:
            return False
        table = self.page_table_map[pid]
        start = vaddr // self.page_size
        end = (vaddr + num_bytes - 1) // self.page_size
        return all(table.has_page(p) for p in range(start, end + 1))

    def _maddr_of(self, pid, vaddr):
        """
        Translates a virtual address to a physical memory index.
        Triggers page-in if the page is not yet loaded.

        Args:
            pid (int): Process ID.
            addr (int): Virtual address.

        Returns:
            int: Index in physical memory array.
        """
        page_num = vaddr // self.page_size
        offset = vaddr % self.page_size
        table = self.page_table_map[pid]
        page = table.get(page_num)
        if not page.is_loaded():
            self._page_in(pid, page_num)
        return page.frame_num * self.page_size + offset

    def _fill_frame(self, frame_num, filler):
        """
        Fills the given frame in memory using the provided filler function.

        Args:
            frame_num (int): Frame number to fill.
            filler (Callable[[int], int]): Function taking index (0..page_size-1) and returning a byte.
        """
        maddr = frame_num * self.page_size
        for i in range(self.page_size):
            self.memory[maddr + i] = filler(i)

    def _page_in(self, pid, page_num):
        """
        Loads a page into memory by assigning a free frame.
        Also known as: "load_page".

        Case 0: If the page is not loaded, this assigns a frame and zero-fills it.
        Simulates demand paging (no actual disk access).
        
        Case 1: If memory is full, this triggers page replacement via FIFO eviction.

        Args:
            pid (int): Process ID.
            page_num (int): Virtual page number to load.

        Raises:
            Exception: If no free frames are available.
        """
        frame_num = self.free_frames.pop(0) if self.free_frames else self._page_out()
        table = self.page_table_map[pid]
        page = table.get(page_num)
        page.frame_num = frame_num
        self.equeue.append((pid, page_num))

        key = (pid, page_num)
        if key in self.store:
            data = self.store.pop(key)
            self._fill_frame(frame_num, lambda i: data[i])
            print(f"[MemoryManager._page_in()] LOAD  pid={pid} â†’ page={page_num:<2} â†’ frame={frame_num} (restored from store)")
        else:
            self._fill_frame(frame_num, lambda i: 0)
            print(f"[MemoryManager._page_in()] LOAD  pid={pid} â†’ page={page_num:<2} â†’ frame={frame_num} (zero-filled)")

    def _page_out(self):
        """
        Evicts one loaded page from memory and returns its freed frame number.
        This simulates basic page replacement when memory is full.
        Also known as: "evict_page".

        Returns:
            int: A frame number that was reclaimed.
        """
        while self.equeue:
            pid, page_num = self.equeue.pop(0)
            table = self.page_table_map[pid]
            page = table.get(page_num)
            
            if not page.is_loaded():
                continue
            
            frame_num = page.frame_num
            page.frame_num = None
            self.free_frames.append(frame_num)
            
            print(f"[MemoryManager._page_out()] EVICT pid={pid} â†’ page={page_num:<2} â†’ freed frame={frame_num}")
            return frame_num
        raise Exception("Eviction failed: no pages available to evict")


class VirtualMemory:
    """
    Represents the virtual memory view for a specific process.
    Provides read/write access using virtual addresses,
    delegating to the system-wide MemoryManager.
    """
    def __init__(self, pid, manager):
        self.pid = pid
        self.manager = manager

    def read(self, vaddr):
        """Read a 2-byte value from the process's virtual memory."""
        return self.manager.read(self.pid, vaddr)

    def write(self, vaddr, value):
        """Write a 2-byte value to the process's virtual memory."""
        self.manager.write(self.pid, vaddr, value)

class ProcessMemory:
    def __init__(self, vmemory):
        self.vmemory = vmemory
        self.symbol_table = {}    # var name â†’ virtual address
        self.next_offset = 0      # Next offset within symbol table
        self.symbol_limit = 64    # Max 64 bytes (â†’ 32 symbol_table)

    def set(self, var, value):
        if var in self.symbol_table:
            addr = self.symbol_table[var]
        elif self.next_offset + 2 <= self.symbol_limit:
            addr = self.next_offset
            self.symbol_table[var] = addr
            self.next_offset += 2
            print(f"[ProcessMemory.set()] symbol_table['{var}'] = {addr}")
        else:
            print(f"[ProcessMemory.set()] DECLARE failed: symbol table full â†’ skipping '{var}'")
            return
        self.vmemory.write(addr, value)

    def get(self, var):
        if var not in self.symbol_table:
            print(f"[ProcessMemory.get()] '{var}' not declared â€” returning 0")
            return 0
        addr = self.symbol_table[var]
        print(f"[ProcessMemory.get()] symbol_table['{var}'] â†’ vaddr={hex(addr)}")
        return self.vmemory.read(addr)


# mm = MemoryManager()
# mm.init(capacity=128, page_size=64)       # Creates 2 frames
# mm.alloc(pid=1, bytes_needed=64)       # Allocates 1 page (for symbol table)

# vmemory = VirtualMemory(pid=1, manager=mm)
# process = Process()
# process.memory = ProcessMemory(vmemory)

# DECLARE(Instruction(["a", "100"]), process)
# DECLARE(Instruction(["b", "250"]), process)
# ADD(Instruction(["c", "a", "b"]), process)

------------------------------
 FILE:  MemoryManager2.py
 PATH:  core\memory\MemoryManager2.py
------------------------------

# This version uses MemoryView instead of VirtualMemory for process memory abstraction.

class PageEntry:
    """
    Represents the metadata of a virtual page (not the actual content).

    This object tracks:
      - which physical frame it's loaded in (if any)
      - whether the page is currently loaded into memory

    Note:
        This does NOT contain the page's data. Content is stored in the
        memory array (RAM) and/or the backing store.
    """

    def __init__(self, frame_num=None):
        self.frame_num = frame_num   # Physical frame index (or None if not loaded)

    def is_loaded(self):
        """True if page is currently loaded in memory (i.e. mapped to a frame)."""
        return self.frame_num is not None


class PageTable:
    def __init__(self):
        self.entries = {}  # Maps virtual page number â†’ PageEntry

    def has_page(self, page_num):
        return page_num in self.entries

    def get(self, page_num):
        return self.entries[page_num]

    def add(self, page_num, page):
        self.entries[page_num] = page

    def pages(self):
        return self.entries.keys()


class MemoryManagerData:
    def __init__(self):
        self.page_size = 0          # Bytes per page/frame
        self.frame_count = 0        # Total number of frames
        self.memory = []            # Physical memory (flat byte array)
        self.free_frames = []       # List of available frame indices
        self.page_table_map = {}    # pid â†’ PageTable
        self.equeue = []            # FIFO eviction queue: (pid, page_num)
        self.store = {}             # Backing store: uint64 key â†’ byte array


class MemoryView:
    """
    Represents the virtual memory view for a specific process.
    Provides read/write access using virtual addresses.

    This object handles:
      - Ownership and access checks
      - Demand paging (pages are loaded into RAM on first access)
      - Read/write of 2-byte values

    âš ï¸ WARNING:
        The methods `read()` and `write()` will automatically
        trigger a page-in if the requested virtual address resides
        on a page that is not yet loaded in memory.
        
        This means these methods can:
          - Modify physical memory state (RAM usage)
          - Trigger evictions (if memory is full)
          - Load pages from the backing store
    """
    def __init__(self, pid, data, page_in):
        self.pid = pid
        self.data = data
        self.page_in = page_in

    def read(self, vaddr) -> tuple[int, bool, bool]:
        """
        Read a 2-byte value from virtual memory.

        Automatically triggers paging if the page(s) are not loaded.

        Args:
            vaddr (int): The starting virtual address (2 bytes will be read).

        Returns:
            (value, is_violation, is_page_fault)
            - value: The read value (0 if failed)
            - is_violation: True if the address was invalid (out-of-bounds or unmapped)
            - is_page_fault: True if a page fault occurred during read
        """
        
        if not self._owns_vaddr(vaddr, num_bytes=2):
            return 0, True, False  # Treat as access violation (bad symbol), ignore is_pagefault

        maddr1 = self._maddr_of(vaddr)
        maddr2 = self._maddr_of(vaddr+1)
        if maddr1 is None or maddr2 is None:
            return 0, False, True  # Page fault

        lower_byte = self.data.memory[maddr1]
        upper_byte = self.data.memory[maddr2] << 8
        return lower_byte | upper_byte, False, False

    def write(self, vaddr, value) -> tuple[bool, bool]:
        """
        Write a 2-byte value to virtual memory.

        Automatically triggers paging if the page(s) are not loaded.

        Args:
            vaddr (int): Starting virtual address to write to
            value (int): 2-byte unsigned integer (0â€“65535)

        Returns:
            (is_violation, is_page_fault)
            - is_violation: True if write was to an invalid address
            - is_page_fault: True if a page fault occurred during write
        """
        if not self._owns_vaddr(vaddr, num_bytes=2):
            return True, False  # Access violation

        maddr1 = self._maddr_of(vaddr)
        maddr2 = self._maddr_of(vaddr+1)
        if maddr1 is None or maddr2 is None:
            return False, True  # Page fault

        self.data.memory[maddr1] = value & 0xFF
        self.data.memory[maddr2] = (value >> 8) & 0xFF
        return False, False

    # ------ PRIVATE METHODS ------

    def _owns_vaddr(self, vaddr, num_bytes=1):
        page_table = self.data.page_table_map.get(self.pid)
        if not page_table:
            return False

        start = vaddr // self.data.page_size
        end = (vaddr + num_bytes - 1) // self.data.page_size
        return all(page_table.has_page(p) for p in range(start, end + 1))

    def _maddr_of(self, vaddr):
        """
        Translate virtual address to physical address.
        Triggers demand paging if page not loaded.
        Returns None only if page_in() fails.
        """
        page_num = vaddr // self.data.page_size
        offset   = vaddr % self.data.page_size
        
        page_table = self.data.page_table_map[self.pid]
        page = page_table.get(page_num)

        if not page.is_loaded():
            success = self.page_in(self.pid, page_num)
            if not success:
                return None
            # Refresh the page reference after page_in()
            page = page_table.get(page_num) # Refresh in case of mutation

        return page.frame_num * self.data.page_size + offset


class MemoryManager:
    def __init__(self):
        self.data = MemoryManagerData()

    def init(self, capacity, page_size):
        """Initialize the memory manager with total capacity and page size."""
        self.data.page_size = page_size
        self.data.frame_count = capacity // page_size
        self.data.memory = [0] * capacity
        self.data.free_frames = list(range(self.data.frame_count))
        self.data.page_table_map.clear()

    def alloc(self, pid, bytes_needed):
        """
        Reserves virtual pages for a process without loading them.
        Pages are created but not assigned frames until accessed.
        """
        pages_needed = (bytes_needed + self.data.page_size - 1) // self.data.page_size

        page_table = PageTable()
        for page_num in range(pages_needed):
            page_table.add(page_num, PageEntry())
        self.data.page_table_map[pid] = page_table
        return True

    def get_vmemory(self, pid):
        """Returns a MemoryView for the given process."""
        return MemoryView(
            pid,
            self.data,
            page_in=lambda pid, page_num: self._page_in(pid, page_num)
        )

    # ------ PRIVATE METHODS ------

    def _fill_frame(self, frame_num, filler):
        """Fills the given frame in memory using the provided filler function."""
        maddr = frame_num * self.data.page_size
        for i in range(self.data.page_size):
            self.data.memory[maddr + i] = filler(i)

    def _page_in(self, pid, page_num):
        """
        Loads a page into memory by assigning a free frame.
        Also known as: "load_page".
        """
        frame_num = (
            self.data.free_frames.pop(0)
            if self.data.free_frames
            else self._page_out()
        )

        if frame_num is False: ########################
            return False

        page_table = self.data.page_table_map[pid]
        page = page_table.get(page_num)
        
        # Sanity check, the current page should not be in memory before page_in is called!
        assert not page.is_loaded(), "page_in() called on already-loaded page"
        
        page.frame_num = frame_num
        self.data.equeue.append((pid, page_num))

        key = self._make_key(pid, page_num)
        if key in self.data.store:
            bytes = self.data.store.pop(key)
            self._fill_frame(frame_num, lambda i: bytes[i])
            print(f"[MemoryManager._page_in()] LOAD  pid={pid} â†’ page={page_num:<2} â†’ frame={frame_num} (restored from store)")
        else:
            self._fill_frame(frame_num, lambda i: 0)
            print(f"[MemoryManager._page_in()] LOAD  pid={pid} â†’ page={page_num:<2} â†’ frame={frame_num} (zero-filled)")
        return True

    def _page_out(self):
        """
        Evicts one loaded page from memory and returns its freed frame number.
        This simulates basic page replacement when memory is full.
        Also known as: "evict_page".
        """
        while self.data.equeue:
            pid, page_num = self.data.equeue.pop(0)
            table = self.data.page_table_map[pid]
            page = table.get(page_num)

            # âœ… This *should* be loaded, otherwise we have stale data
            assert page.is_loaded(), "page_out() called on an already-evicted page"

            frame_num = page.frame_num
            page.frame_num = None
            self.data.free_frames.append(frame_num)

            # Save to store
            maddr = frame_num * self.data.page_size
            bytes_out = self.data.memory[maddr: maddr + self.data.page_size]

            key = self._make_key(pid, page_num)
            self.data.store[key] = list(bytes_out)

            print(f"[MemoryManager._page_out()] EVICT pid={pid} â†’ page={page_num:<2} â†’ freed frame={frame_num}")
            return frame_num

        raise Exception("Eviction failed: no pages available to evict") ########################

    def _make_key(self, pid, page_num):
        return (pid << 32) | page_num


class ProcessMemory:
    def __init__(self, view):
        self.view = view
        self.symbol_table = {}    # var name â†’ virtual address
        self.next_offset = 0      # Next offset within symbol table
        self.symbol_limit = 64    # Max 64 bytes (â†’ 32 variables)

    def set(self, var, value) -> tuple[bool, bool]:
        """
        Writes a 2-byte value to a variable.

        Returns:
            is_violation (bool): True if address assignment was invalid (e.g. symbol table full)
            is_page_fault (bool): True if the write triggered a page fault
        """
        if var in self.symbol_table:
            addr = self.symbol_table[var]

        elif self.next_offset + 2 <= self.symbol_limit:
            addr = self.next_offset
            self.symbol_table[var] = addr
            self.next_offset += 2
            print(f"[ProcessMemory.set()] symbol_table['{var}'] = {addr}")

        else:
            print(f"[ProcessMemory.set()] DECLARE failed: symbol table full â†’ skipping '{var}'")
            return True, False  # Violation, but no page fault

        return self.view.write(addr, value) # Returns (is_violation, is_page_fault)
    
    def get(self, var) -> tuple[int, bool, bool]:
        """
        Returns:
            value (int): the variable's value or 0
            is_violation (bool): True if address was invalid (e.g. undeclared or out of bounds)
            is_page_fault (bool): True if a page fault occurred
        """
        if var not in self.symbol_table:
            print(f"[ProcessMemory.get()] '{var}' not declared")
            return 0, False, True ######################## CREATE VARIABLE IF NOT CREATED   

        addr = self.symbol_table[var]
        print(f"[ProcessMemory.get()] symbol_table['{var}'] â†’ vaddr={hex(addr)}")
        
        return self.view.read(addr) # Returns (value, is_violation, is_page_fault)

------------------------------
 FILE:  MemoryManagerData.hpp
 PATH:  core\memory\MemoryManagerData.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "types.hpp"


class MemoryManagerData {
  public:

  MemoryManagerData():
    page_size      (0u),    
    frame_count    (0u),
    memory         (vec<uint>()),
    free_frames    (deque<uint>()),
    // page_table_map (map<uint,PageTable>()),
    // equeue         (deque<tup<uint, uint>>()),
    // store          (map<uint64,vec<uint>>()) {}

  // ------ Member variables ------
  uint page_size;
  uint frame_count;
  vec<uint> memory;
  deque<uint> free_frames;
  map<uint,PageTable> page_table_map;
  deque<tup<uint, uint>> equeue;
  map<uint64,vec<uint>> store;
};

------------------------------
 FILE:  MemoryView.hpp
 PATH:  core\memory\MemoryView.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "MemoryManagerData.hpp"
#include "types.hpp"


class MemoryView {
  public:

  MemoryView(uint pid, MemoryManagerData& data, func<bool(uint, uint)> page_in):
    pid     (pid),        // Process ID owning this memory view
    data    (data),       // Reference to shared memory manager state (frames, tables, store, etc.)
    page_in (page_in) {}  // Page-in callback: loads (pid, page_num) into memory if not present

  /**
   * @brief Reads a 2-byte value from virtual memory.
   * @return (value, is_violation, is_page_fault)
   *         - value: the uint16 read from memory (or 0 if failed)
   *         - is_violation: true if address is invalid or unmapped
   *         - is_page_fault: true if a page fault occurred
   */
  auto read(uint vaddr) -> tup<int, bool, bool> {
    if (!has_pages_for(vaddr, 2))
      return {0, true, false}; // access violation

    auto m1 = maddr_of(vaddr);      
    auto m2 = maddr_of(vaddr + 1);
    if (!m1 || !m2)
      return {0, false, true}; // page fault

    auto lower_byte = data.memory[*m1];
    auto upper_byte = data.memory[*m2] << 8;
    return {lower_byte | upper_byte, false, false};
  }
    
  /**
   * @brief Writes a 2-byte value to virtual memory.
   * @return (is_violation, is_page_fault)
   *        - is_violation: true if address is invalid or unmapped
   *        - is_page_fault: true if a page fault occurred
   */
  auto write(uint vaddr, uint value) -> tup<bool, bool> {
    if (!has_pages_for(vaddr, 2))
      return {true, false}; // access violation

    auto m1 = maddr_of(vaddr);
    auto m2 = maddr_of(vaddr+1);
    if (!m1 || !m2)
      return {false, true}; // page fault

    data.memory[*m1] = value & 0xFF;
    data.memory[*m2] = (value >> 8) & 0xFF;
    return {false, false};
  }

  // ------ Member variables ------
  uint pid;
  MemoryManagerData& data;
  func<bool(uint,uint)> page_in;
  
  // ------ Internal Helpers ------
  private:

  /** @brief Checks whether the process has declared all pages needed for a virtual memory access. */
  auto has_pages_for(uint vaddr, uint num_bytes=1) -> bool {
    auto it = data.page_table_map.find(pid);
    if (it == data.page_table_map.end())
      return false;
    
    auto& page_table = it->second;
    auto start = vaddr / data.page_size;
    auto end = (vaddr + num_bytes - 1) / data.page_size;

    for (auto page_num=start; page_num <= end; ++page_num)
      if (!page_table.has_page(page_num))
        return false;
    return true;
  }

  /**
   * @brief Translates a virtual address to a physical memory address for the current process.
   * Triggers a page-in if the page is not loaded; returns nullopt on failure.
   * Returns the physical address (frame * page_size + offset) if successful.
   */
  auto maddr_of(uint vaddr) -> opt<uint> {
    auto page_num = vaddr / data.page_size;
    auto offset   = vaddr % data.page_size;
    auto& page_table = data.page_table_map.at(pid);
    auto& page = page_table.get(page_num);

    if (!page.is_loaded() && !page_in(pid, page_num)) // Note: page_in method has side effects
      return nullopt;
    return page.frame() * data.page_size + offset;
  }
};

------------------------------
 FILE:  types.hpp
 PATH:  core\memory\types.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


/** @brief Represents the metadata of a virtual page (not the actual content). */
class PageEntry {
  public:

  PageEntry():
  frame_num (nullopt) {} // The physical frame index (nullopt if not loaded)
  
  /** @brief Returns true if this page is loaded in a physical frame. */
  auto is_loaded() -> bool { return frame_num.has_value(); }
  
  /** @brief Returns the physical frame number. Throws if not loaded. */
  auto frame() -> uint { return frame_num.value(); }
  
  // ------ Member variables ------
  opt<uint> frame_num;
};


/**
 * @brief Represents the page table for a process.
 * Maps virtual page numbers to their PageEntry metadata.
 */
class PageTable {
  public:

  PageTable(): 
    entries (map<uint,PageEntry>()) {}  // Virtual page number: metadata

  /** @brief Returns true if this table tracks the given virtual page. */
  auto has_page(uint page_num) -> bool { return entries.contains(page_num); }

  /** @brief Returns a reference to the PageEntry for the given page. */
  auto get(int page_num) -> PageEntry& { return entries.at(page_num); }

  /** @brief Adds a PageEntry to the table for the given page number. */
  void add(uint page_num, PageEntry page) { entries[page_num] = page; }

  /** @brief Returns a view of all stored virtual page numbers. */
  auto pages() -> vec<uint> {
    auto keys = vec<uint>();
    keys.reserve(entries.size());

    for (auto& [key, _]: entries)
      keys.push_back(key);
    return keys;
  }

  // ------ Member variables ------
  map<uint,PageEntry> entries;
};

------------------------------
 FILE:  Maze.hpp
 PATH:  core\misc\Maze\Maze.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "Position.hpp"

namespace csopesy {
  class Maze {
    using list    = vector<int>;
    using Symbols = array<str, 17>;
    using Row     = vector<byte>;
    using Grid    = vector<Row>;

    static constexpr byte PATH = 0;
    static constexpr byte STEP = 16;
    static constexpr byte WALL = 255;
    inline static const Symbols symbols = {
      " ", "â•‘", "â•", "â•”", "â•", "â•—", "â•", "â•¦",
      "â•‘", "â•‘", "â•š", "â• ", "â•", "â•£", "â•©", "â•¬",
      "Â·",
    };

    uint width;
    uint height;
    Grid grid;

    public:
    Maze(uint width, uint height): 
      width(width), 
      height(height), 
      grid(height, Row(width, WALL)) {
      generate();
    }

    str render() const {
      auto stream = osstream();
      for (const auto& row: grid) {
        for (const auto& cell: row)
          stream << symbols[cell];
        stream << '\n';
      }
      return stream.str();
    }

    private:
    bool in_bounds(int x, int y) const {
      return x >= 0 && x < width && y >= 0 && y < height;
    }

    bool is_wall(int x, int y) const {
      return grid[y][x] != PATH;
    }

    void generate() {
      using Position::pos;

      list dirs  = { pos(1,0), pos(0,1), pos(-1,0), pos(0,-1) };
      list stack = { pos(1,1) };
      stack.reserve((width * height) / 2);
      
      while (!stack.empty()) {
        // Pop the current cell (top of the stack)
        auto [x, y] = pos(stack.back());
        stack.pop_back();
        
        for (auto dir: Rand::shuffle(dirs)) {
          auto [dx, dy] = pos(dir);
          int nx = x + dx*2;
          int ny = y + dy*2;

          // Choose a random unvisited neighbor
          if (!in_bounds(nx, ny) || !is_wall(nx, ny)) 
            continue;

          // Remove the wall between the current cell and the chosen neighbor
          grid[y+dy][x+dx] = PATH;
          grid[ny][nx] = PATH;

          // Add the current position and the new position to the stack
          stack.push_back(pos(x, y));
          stack.push_back(pos(nx, ny));
          break;
        }
      }

      format();
    }

    void format() {
      for (int y=0; y < height; ++y) {
        for (int x=0; x < width; ++x) {
          // Skip empty spaces
          if (!is_wall(x, y)) continue;

          byte bits = 0;
          if (y > 0 && is_wall(x, y-1))        bits |= 0b1000;  // Check if there's a top wall
          if (x > 0 && is_wall(x-1, y))        bits |= 0b0100;  // Check if there's a left wall
          if (x < width-1 && is_wall(x+1, y))  bits |= 0b0010;  // Check if there's a right wall
          if (y < height-1 && is_wall(x, y+1)) bits |= 0b0001;  // Check if there's a bottom wall

          // Set the grid's value to the correct symbol based on the bitmask
          grid[y][x] = bits;
        }
      }
    }
  };
}

------------------------------
 FILE:  Position.hpp
 PATH:  core\misc\Maze\Position.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"

namespace csopesy::Position {  
  
  // Encode two integers (x, y) into a single integer
  inline int pos(int x, int y) {
    return (x << 16) | (y & 0xFFFF);
  }

  // Decode a single encoded integer back into a position (x, y)
  inline pair<int, int> pos(int encoded) {
    int x = encoded >> 16;
    int y = encoded & 0xFFFF;
    
    // If y is negative, sign-extend it properly
    return { x, (y & 0x8000 ) ? (y | 0xFFFF0000) : y };
  }
}

------------------------------
 FILE:  Process.hpp
 PATH:  core\process\Process.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "core/instruction/InstructionInterpreter.hpp"
#include "ProcessData.hpp"


class Process {
  public:  
  // ------ Class variables ------
  inline static auto& interpreter = InstructionInterpreter::get();

  /** @brief Creates a process with a random instruction script. */
  Process(uint pid, str name, uint size): 
    data(           // Data container of process
      ProcessData(
        pid,
        move(name),
        move(interpreter.generate_script(size))
      )
    ) {}

  /** @brief Executes a single instruction step for the given process. */
  auto step() -> bool {
    auto& program = data.program;
    if (program.finished())
      return true;          
      
    auto ip = program.ip; 
    auto& inst = data.program.script.at(ip);
    interpreter.execute(inst, data);

    // Don't auto-advance ip if it was not manually set
    if (!program.ip_was_set)
      program.ip++;
    
    program.ip_was_set = false;
    return false;
  }

  // ------ Instance variables ------
  ProcessData data;
};

------------------------------
 FILE:  ProcessControl.hpp
 PATH:  core\process\ProcessControl.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "ProcessProgram.hpp"


/**
 * @brief Tracks the execution state of a process.
 * 
 * Supports transitions between Ready, Sleeping, and Finished states,
 * and stores the number of ticks remaining for a sleeping process.
 */
class ProcessControl {
  public:

  ProcessControl():
    sleep_ticks (0) {}
  
  /** @brief Returns true if the process is currently sleeping. */
  auto sleeping() const -> bool { return sleep_ticks > 0; }    
  
  /** @brief Puts the process to sleep for a number of ticks. */
  void sleep_for(uint ticks) { sleep_ticks = ticks; }
  
  /** @brief Advances sleep state by one tick, if sleeping. */
  void tick() { if (sleep_ticks > 0) --sleep_ticks; }
  
  // ------ Instance variables ------
  uint sleep_ticks;
};

------------------------------
 FILE:  ProcessData.hpp
 PATH:  core\process\ProcessData.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"
#include "ProcessMemory.hpp"
#include "ProcessProgram.hpp"
#include "ProcessControl.hpp"
#include "types.hpp"


/**
 * @brief Pure data container for process state.
 * 
 * This class holds all memory, program, state, and metadata
 * related to a single process. It is only accessible by the
 * Process class, which owns and manipulates this data.
 */
class ProcessData {
  public:

  /** @brief Constructs a process given name and process ID. */
  ProcessData(uint id, str name, vec<Instruction> script): 
    id      (id),                     // Unique process ID
    name    (move(name)),             // Human-readable process name (e.g. p01, p02)
    logs    (vec<str>()),             // Output logs collected from PRINT instructions
    core_id (0u),                     // ID of the core this process is assigned to (0 if unassigned)
    stime   (Clock::now()),           // Timestamp of when the process was created
    program (ProcessProgram(script)), // List of instructions and execution context
    control (ProcessControl()),       // Sleep controller of the process
    memory  (ProcessMemory()) {}      // Key-value variable store (e.g. for DECLARE, ADD, etc.)

  /** @brief Append a log message (used for PRINT instructions) */
  void log(str line) { logs.push_back(move(line)); }

  // ------ Instance variables ------
  uint id;            
  str name;          
  vec<str> logs;         
  uint core_id;       
  Time stime;        
  ProcessProgram program; 
  ProcessControl control; 
  ProcessMemory memory;   
};

------------------------------
 FILE:  ProcessMemory.hpp
 PATH:  core\process\ProcessMemory.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "types.hpp"


class ProcessMemory { 
  public:
  
  ProcessMemory():
    symbol_table (map<str,uint>()) {}

  /** Memory mutators */
  void set(str key, uint value) {
    symbol_table[move(key)] = value;
  }
  
  /** Memory accessors */
  auto get(const str& key) const -> uint {
    auto it = symbol_table.find(key);
    return it != symbol_table.end() ? it->second : 0;
  }
  
  /** Resolves a token as a literal or variable lookup */
  auto resolve(const str& token) const -> uint {
    return isdigit(token[0]) ? stoul(token) : get(token);
  }
  
  /** Exposes internal variable bindings */
  auto get_symbol_table() -> map<str,uint>& {
    return symbol_table;
  }

  // ------ Instance variables ------
  map<str,uint> symbol_table;
};

------------------------------
 FILE:  ProcessProgram.hpp
 PATH:  core\process\ProcessProgram.hpp
------------------------------

#pragma once
#include "core/instruction/Instruction.hpp"
#include "types.hpp"

  
/**
 * @brief A program that can be executed by a process.
 * 
 * Contains a flat list of instructions, an instruction pointer,
 * and a control context stack (used by FOR loops).
 */
class ProcessProgram {
  public:

  /** @brief Loads an instruction script. */
  ProcessProgram(vec<Instruction> script): 
    script     (vec<Instruction>(move(script))),  // Flat list of all program instructions
    context    (ContextStack()),                     // Stack of active loop contexts
    ip_was_set (false),                              // For blocking instruction pointer advancing
    ip         (0) {}                                // Current instruction pointer

  /** @brief Returns the size of the script. */
  auto size() -> uint { return script.size(); }
  
  /** @brief Check if the program has completed execution. */
  auto finished() -> bool { return ip >= script.size(); }

  /** @brief Manually sets the instruction pointer to a specific address. */
  void set_ip(uint addr) {
    ip_was_set = true;
    ip = addr;
  }

  /** @brief Returns a formatted view of all instructions with the current IP highlighted. */
  auto render_script() -> str {
    // Compute the width needed to align inst indices
    uint width = count_digits(script.size()-1);
    auto out = osstream();
    
    // Render each instruction line, marking the current IP with a '>'
    for (uint i=0; i < script.size(); ++i)
      out << render_line(i, width);

    return out.str();
  }

  /** @brief Returns a formatted view of the current context stack. */
  auto render_context() -> str {
    // If there are no loop frames, return empty
    if (context.empty()) 
      return "  <empty>\n";  
    
    // Compute width for formatting inst indices
    uint width = count_digits(script.size()-1); 
    auto out = osstream();

    // Render each loop frame (used by nested FOR instructions)
    for (uint i=0; i < context.size(); ++i)
      out << render_frame(i, width);

    return out.str();
  }

  // ------ Instance variables ------

  vec<Instruction> script;
  ContextStack context;
  bool ip_was_set;
  uint ip;

  // ------ Internal logic ------

  private:

  /** @brief Helper to renders a single instruction line from the script with formatting. */
  auto render_line(uint idx, uint width) -> str {
    char marker = (idx == ip) ? '>' : ' ';
    auto opcode = script[idx].opcode.substr(0, 10);
    auto line = osstream();
    line << format("{} [{:0{}}] {:<{}}", marker, idx, width, opcode, 10);

    for (auto& arg: script[idx].args)
      line << ' ' << arg;
    line << '\n';

    return line.str();
  }

  /** @brief Helper to renders a single loop frame from the context stack with formatting. */
  auto render_frame(uint idx, uint width) -> str {
    auto& frame = context.at(idx);
    auto& inst = script[frame.ip];
    auto out = osstream();

    out << format("  [{}]", idx);
    out << format(" @{:0{}}", frame.ip, width);
    out << format("  exit: {:0{}}", inst.exit, width);
    out << format("  count: {}", frame.ctr);
    out << '\n';
    return out.str();
  }
};

------------------------------
 FILE:  types.hpp
 PATH:  core\process\types.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/instruction/Instruction.hpp"


/** A loop frame from a FOR-like instruction. */
struct ContextFrame {
  uint ip;    // Address where the loop starts
  uint ctr;   // Number of iterations remaining
};

/**
  * @brief A stack structure used for managing nested FOR loop contexts.
  * 
  * Stores control frames for tracking loop entry points, exit conditions, 
  * and iteration counts during process execution. Could also be used to
  * track sleep.
  */
class ContextStack {
  public:

  ContextStack():
    stack (vec<ContextFrame>()) {}

  /** Returns true if the top frame starts at the given instruction pointer. */
  auto top_ip_is(uint ip) -> bool {  return !empty() && top().ip == ip; }

  /** Push a new context onto the stack. */
  void push(uint start, uint count=0) { stack.emplace_back(start, count); }

  /** Pop the top context from the stack. */
  void pop() { stack.pop_back(); }

  /** Check if the context stack is empty. */
  auto empty() -> bool { return stack.empty(); }

  /** Get the number of contexts in the stack. */
  auto size() -> uint { return stack.size(); }

  /** Clear all contexts from the stack. */
  void clear() { stack.clear(); }

  /** Access the top context */
  auto top() -> ContextFrame& { return stack.back(); }

  /** Access a context by index. */
  auto at(uint index) -> ContextFrame& { return stack.at(index); }

  private:

  // ------ Instance variables ------
  vec<ContextFrame> stack;
};

------------------------------
 FILE:  Scheduler.hpp
 PATH:  core\scheduler\Scheduler.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/process/Process.hpp"
#include "core/execution/CoreManager.hpp"
#include "strategies/_all.hpp"
#include "SchedulerStrategy.hpp"
#include "SchedulerData.hpp"
#include "types.hpp"


/**
 * @brief Central scheduler controller for the OS simulation.
 * 
 * Owns the strategy, configuration, interpreter, and high-level
 * orchestration of ticks and process generation.
 */
class Scheduler {
  public:

  Scheduler():
    names      (vec<str>()),            // Deferred generation list for user-inserted process table
    ticks      (0u),                    // Global tick counter
    generating (false),                 // Flag indicating auto-generation mode
    data       (SchedulerData()),       // Internal state (cores, process table, vec<str>)
    strategy   (SchedulerStrategy()) {} // Contains the scheduler strategy

  /** Adds a user-named process to the pending generation vec<str>. */
  void generate_process(str name) { names.push_back(move(name)); }

  /** Enables or disables automatic process generation each tick. */
  void generate(bool flag) { generating = flag; }

  /** @brief Executes the active strategy logic and increments the tick count. */
  void tick() {
    if (!data.config.getb("initialized")) return;

    try {
      // Generate batch processes
      generate_processes();

      // Release finished or preempted cores
      release_processes();
      
      /** TODO: Clean/update paging info. */ 
      // memory.tick(data);
      
      // Tick sleeping processes in the waiting queue
      tick_sleeping_processes();

      // Assign new processes to idle cores
      strategy.tick(data);
      ++ticks;

    } catch (exception& e) {
      cerr << format("[Scheduler] tick(): Exception: {}\n", e.what());
      throw;
    }
  }

  /** @brief Applies a new configuration and resizes core state accordingly. */
  void set_config(Config config) {
    strategy = get_scheduler_strategy(config.gets("scheduler"));
    auto core_size = config.getu("num-cpu");
    auto preempt_handler = strategy.get_preempt_handler(data);  // Create handler from factory method
    auto delay = config.getu("delays-per-exec");
    
    // Resizes number of cores (destroys old ones if any)
    data.cores.init(core_size);

    // Configure cores with the tick delay and preempt handler (if any)
    for (auto& ref: data.cores.get_all()) {
      auto& core = ref.get();
      core.init(delay, preempt_handler);
    }

    data.config = move(config); // Must come last                               
  }

  // ------ Instance variables ------

  vec<str> names;                
  uint ticks;             
  bool generating;    
  SchedulerData data;         
  SchedulerStrategy strategy;

  // ------ Internal logic ------

  private:

  /** @brief Helper that checks if the current tick matches the process generation interval. */
  auto interval_has_elapsed() -> bool {
    uint freq = data.config.getu("batch-process-freq");
    return freq > 0 && (ticks % freq == 0);
  }

  /** @brief Helper that generates user and scheduler-enqueued processes. */
  void generate_processes() {
    auto make_process = [&](uint pid, str name="") {
      auto pname = name.empty() ? format("p{:02}", pid) : move(name);
      auto min = data.config.getu("min-ins");
      auto max = data.config.getu("max-ins");
      auto size = Rand::num(min, max);

      data.add_process(Process(pid, move(pname), size));
      data.rqueue.push(pid);
    };

    for (auto& name: names)
      make_process(data.new_pid(), move(name));
    names.clear();

    if (generating && interval_has_elapsed())
      make_process(data.new_pid());
  }

  /** @brief Helper that releases finished or preempted processes in cores. */
  void release_processes() {
    for (auto& ref: data.cores.get_releasable()) {
      auto& core = ref.get();
      auto& process = core.get_job();
      core.release();

      if (process.data.program.finished())
        data.finished_pids.push_back(process.data.id);
      else if (process.data.control.sleeping())
        data.wqueue.push_back(process.data.id);     
      else                                      
        data.rqueue.push(process.data.id);  // Not finished, not sleeping â†’ just resume later
    }
  }

  /** @brief Steps processes in wqueue. Returns processes to the ready queue once they're not sleeping. */
  void tick_sleeping_processes() {
    auto& wqueue = data.wqueue;
    for (auto it = wqueue.begin(); it != wqueue.end(); ) {
      auto& process = data.get_process(*it);
      process.step();           // decrement sleep_ticks

      if (process.data.control.sleeping())
        ++it;                   // still sleeping
      else {
        data.rqueue.push(*it);  // ready again
        it = wqueue.erase(it);  // remove from wqueue  
      }
    }
  }
};

------------------------------
 FILE:  SchedulerData.hpp
 PATH:  core\scheduler\SchedulerData.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/process/Process.hpp"
#include "core/execution/CoreManager.hpp"
#include "types.hpp"


/**
 * @brief Encapsulates scheduling context passed to strategy functions.
 * 
 * Provides access to the current core vec<uint>, ready queue, and tick counter.
 * Also handles state reset and tick progression during simulation.
 */
class SchedulerData {  
  public:
  
  SchedulerData():
    proc_table    (map<uint,uptr<Process>>()),  // Container for all processes
    finished_pids (vec<uint>()),                // PIDs of Finished processes 
    rqueue        (queue<uint>()),              // Ready queue of processes waiting to be scheduled
    wqueue        (list<uint>()),               // Ready queue of processes waiting to be scheduled
    next_pid      (atomic_uint{1}),             // PID counter for generating unique process IDs
    config        (Config()),          // Runtime configuration settings
    cores         (CoreManager()) {}            // Owned instance of scheduler core manager

  /** @brief Returns a unique, incrementing process ID. */
  auto new_pid() -> uint { return next_pid++; }

  /** @brief Adds a process to the process table. */
  void add_process(Process proc) {
    auto id = proc.data.id;
    auto ptr = make_unique<Process>(move(proc));
    proc_table.emplace(id, move(ptr)); 
  }

  /** @brief Check if a process with the given ID exists. */
  auto has_process(uint id) -> bool { return proc_table.contains(id); }

  /** @brief Check if a process with the given name exists. */
  auto has_process(const str& name) -> bool { return !!find_process_by_name(name, false); }
  
  /** @brief Returns a reference wrapper to the process with the given PID. */
  auto get_process(uint id) -> Process& { return *proc_table.at(id); }

  /** @brief Returns a reference wrapper to the process with the given name. */
  auto get_process(const str& name) -> Process& { return *find_process_by_name(name); }
  
  /** @brief Returns the vec<uint> of running process IDs. */
  auto get_running_pids() -> vec<uint> { return cores.get_running_pids(); }

  // ------ Instance variables ------

  map<uint, uptr<Process>> proc_table;
  vec<uint> finished_pids;         
  queue<uint> rqueue;                 
  list<uint> wqueue;                 
  Config config;
  CoreManager cores;                  
  atomic_uint next_pid;           

  // ------ Internal logic ------

  private:

  /** @brief Returns a pointer to a process given a name, or throws if not found (if enabed). */
  auto find_process_by_name(const str& name, bool throw_if_missing=true) -> Process* {
    for (auto& [_, proc]: proc_table)
      if (proc->data.name == name)
        return proc.get();
  
    if (throw_if_missing)
      throw runtime_error(format("Process with name '{}' not found.", name));
    return nullptr;
  }
};

------------------------------
 FILE:  SchedulerStrategy.hpp
 PATH:  core\scheduler\SchedulerStrategy.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/execution/Core.hpp"
#include "core/scheduler/SchedulerData.hpp"

  
/**
 * @brief Represents a pluggable scheduling strategy (e.g., FCFS, RR).
 * 
 * Allows dynamic assignment of tick behavior and preemption policy.
 * Each strategy defines how proc_table are selected for execution,
 * and whether/when a running process should be preempted.
 */
class SchedulerStrategy {
  public:

  using PreemptFactory = func<Core::func(SchedulerData&)>;
  using TickHandler = func<void(SchedulerData&)>;

  SchedulerStrategy():
    name            (""s),                // Strategy identifier (e.g., "fcfs", "rr")
    tick_handler    (nullptr),            // Main strategy logic executed each tick
    preempt_factory (nullptr) {}          // Core-level preemption policy (optional)

  /** @brief Sets the strategy name. */
  auto set_name(str n) -> SchedulerStrategy& { return name = n, *this; }

  /** @brief Sets the main logic to run on each tick. */
  auto on_tick(TickHandler t) -> SchedulerStrategy& { return tick_handler = move(t), *this; }

  /** @brief Sets the per-core preemption policy. */
  auto on_preempt(PreemptFactory f) -> SchedulerStrategy& { return preempt_factory = move(f), *this;}

  /** @brief Returns a Core-level preemption lambda bound to current SchedulerData. */
  auto get_preempt_handler(SchedulerData& data) -> Core::func {
    if (!preempt_factory) return nullptr;
    return preempt_factory(data);
  }

  // === Execution ===

  /** @brief Invokes the tick handler logic on the current scheduler data. */
  void tick(SchedulerData& data) {
    if (!tick_handler)
      throw runtime_error("SchedulerStrategy::tick called without on_tick handler.");
    tick_handler(data);
  }

  // ------ Instance variables ------

  str name;              
  TickHandler tick_handler;       
  PreemptFactory preempt_factory;
};

------------------------------
 FILE:  types.hpp
 PATH:  core\scheduler\types.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


/**
 * @brief Dynamic scheduler configuration using key-value pairs with std::any.
 * 
 * Supports storing any type but only str, uint, and bool are officially supported.
 */
class Config {
  public:

  Config():
    entries (ordered_map<str,any>())  // Ordered map (alphabetically) of scheduler configs
  {
    set("scheduler", "fcfs"s);
    set("num-cpu", 1u);
    set("quantum-cycles", 1u);
    set("batch-process-freq", 1u);
    set("min-ins", 1u);
    set("max-ins", 1u);
    set("delays-per-exec", 0u);
    set("initialized", false);
  }

  /** @brief Sets the value of a configuration key. */
  void set(const str& key, any value) { entries[key] = move(value); }

  /** @brief Returns true if key exists. */
  auto has(const str& key) const -> bool { return entries.contains(key); }

  // ------ Getters ------
  
  auto all() -> ordered_map<str,any>& { return entries; }

  /** @brief Retrieves the value of a key as a string. */
  auto gets(const str& key) -> str { return get<str>(key); }

  /** @brief Retrieves the value of a key as an unsigned integer. */
  auto getu(const str& key) -> uint { return get<uint>(key); }
  
  /** @brief Retrieves the value of a key as a boolean. */
  auto getb(const str& key) -> bool { return get<bool>(key); }

  // ------ Static Helpers ------

  /** @brief Parses a raw string into a typed value (bool, uint, or str). */
  static auto parse(const str& raw) -> any {
    // Lowercase copy for comparison
    auto lower = lowercase(raw);

    // Check if it's a boolean
    if (lower == "true")  return true;
    if (lower == "false") return false;

    // Check if it's a number (digits only)
    if (is_digits(raw))
      return cast<uint>(stoul(raw));

    // Default to string
    return raw;
  }

  private:

  // ------ Instance variables ------
  ordered_map<str,any> entries;

  // ------ Internal helpers ------

  /** @brief Gets the value of a configuration key with expected type. */
  template <typename Type>
  auto get(const str& key) -> Type {
    if (!entries.contains(key))
      throw runtime_error(format("Missing config key '{}'", key));

    try {
      return cast<Type>(entries.at(key));

    } catch (bad_any_cast& e) {
      throw runtime_error(format("Config key '{}' has wrong type: {}", key, e.what()));
    }
  }
};

------------------------------
 FILE:  fcfs.hpp
 PATH:  core\scheduler\strategies\fcfs.hpp
------------------------------

#include "core/common/imports/_all.hpp"
#include "core/scheduler/SchedulerData.hpp"
#include "core/scheduler/SchedulerStrategy.hpp"


/**
 * Standard, Lazy, Non-Preemptive, Immediate-Arrival FCFS strategy.
 *
 * Characteristics:
 * - Non-preemptive: process runs to completion once assigned
 * - Lazy: cores pull from the queue only when idle
 * - Immediate-arrival: proc_table are enqueued as soon as they arrive
 */
auto make_fcfs_strategy() -> SchedulerStrategy {

  // Standard, Lazy, Non-Preemptive, Immediate-Arrival FCFS
  return SchedulerStrategy()
    .set_name("fcfs")

    .on_tick([](SchedulerData& data) {;
      for (auto& ref: data.cores.get_idle()) {

        // If no process is ready, stop assigning
        if (data.rqueue.empty()) break;     
        
        // Assign the selected process to the current idle core
        auto& core = ref.get();
        uint pid = data.rqueue.front(); 
        data.rqueue.pop();
        core.assign(data.get_process(pid));
      }
  });
}

------------------------------
 FILE:  rr.hpp
 PATH:  core\scheduler\strategies\rr.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/execution/Core.hpp"
#include "core/scheduler/SchedulerData.hpp"
#include "core/scheduler/SchedulerStrategy.hpp"


/**
 * Round-Robin Strategy (preemptive).
 * 
 * Characteristics:
 * - Preemptive: proc_table are interrupted after a time quantum.
 * - Immediate arrival: proc_table are placed into the ready queue directly.
 */
auto make_rr_strategy() -> SchedulerStrategy {
  return SchedulerStrategy()
    .set_name("rr")

    .on_tick([](SchedulerData& data) {
      for (auto& ref: data.cores.get_idle()) {
    
        // If no process is ready, stop assigning
        if (data.rqueue.empty()) break;
        
        auto& core = ref.get();
        uint pid = data.rqueue.front(); 
        data.rqueue.pop();
        core.assign(data.get_process(pid));
      }
    })

    .on_preempt([](SchedulerData& data) -> Core::func {
      auto quantum = data.config.getu("quantum-cycles");
      
      return [quantum](Core& core) -> bool {
        return core.job_ticks >= quantum;
      };
    });
}

------------------------------
 FILE:  _all.hpp
 PATH:  core\scheduler\strategies\_all.hpp
------------------------------

#pragma once
#include "core/scheduler/SchedulerStrategy.hpp"
#include "fcfs.hpp"
#include "rr.hpp"


auto get_scheduler_strategy(const str& name) -> SchedulerStrategy {
  if (name == "fcfs") return make_fcfs_strategy();
  if (name == "rr")   return make_rr_strategy();
  throw runtime_error(format("Unknown strategy name: {}", name));
}

------------------------------
 FILE:  Shell.hpp
 PATH:  core\shell\Shell.hpp
------------------------------

#include "internal/Shell.impl.hpp"        // Must be included first to fully define Shell
#include "core/command/handlers/_all.hpp" // Must be included after since handlers use Shell&

  
/**
 * @brief Populates the CommandInterpreter with all available commands.
 * 
 * Defined separately so the Shell class is fully known before
 * including handlers that use Shell&.
 */
void Shell::register_commands() {
  for (auto handler: get_command_handlers())
    interpreter.register_command(move(handler));
}

------------------------------
 FILE:  ShellBanner.hpp
 PATH:  core\shell\ShellBanner.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/common/utility/RichText.hpp"
#include "core/common/utility/Text.hpp"

/** @brief Renders and styles the shell banner using a vertical gradient. */
class ShellBanner {
  public:

  /** @brief Returns the full banner as a string with vertical gradient applied. */
  auto get() -> str {
    auto mint = vec<int>{201, 254, 221};
    auto coral = vec<int>{249, 121, 121};
    auto gradient = make_gradient(coral, mint, lines.size());
    
    auto out = osstream();
    out << "\n\n";
    for (uint i = 0; i < lines.size(); ++i) {
      int code = rgb_to_ansi256(gradient[i]);
      out << Text(lines[i])[format("fg{}+pc", code)] << '\n';
    }

    out << '\n';
    out << Text(names)[format("pc+fg{}", rgb_to_ansi256(mint))] << "\n\n";

    // Add onboarding message
    out << RichText("[fg=#88a17a]To get started:[/]\n");
    out << RichText("  1. Type [b fg=#d39c6a]demo[/] to see a sample process in action.\n");
    out << RichText("  2. Then [b fg=#d39c6a]exit[/] to leave the shell.\n");
    out << RichText("  3. Use [b fg=#d39c6a]help[/] for more information on commands.\n\n\n");
    return out.str();
  }

  private:

  // ------ Internal helpers ------

  static inline const auto names = "Dicayanan | Maramag | Maunahan | Villaver"s;
  static inline const auto lines = vec<str>{
    "  â–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  ",
    " â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â•â• â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ•— ",
    "â–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•‘      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â•šâ–ˆâ–ˆâ•—",
    "â•šâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘      â•šâ•â•â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•â•â•  â–ˆâ–ˆâ•”â•â•â•   â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•”â•",
    " â•šâ–ˆâ–ˆâ•— â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â• ",
    "  â•šâ•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•  â•šâ•â•â•â•â•â•  â•šâ•â•      â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•â•    â•šâ•â•    â•šâ•â•  ",
  };

  /** @brief Computes N evenly spaced vec<int> values between two endpoints. */
  auto make_gradient(vec<int>& from, vec<int>& to, uint steps) -> vec<vec<int>> {
    auto result = vec<vec<int>>();
    result.reserve(steps);

    for (uint i = 0; i < steps; ++i) {
      float t = (steps == 1) ? 0.f : float(i) / (steps - 1);
      int r = int(from[0] + (to[0] - from[0]) * t);
      int g = int(from[1] + (to[1] - from[1]) * t);
      int b = int(from[2] + (to[2] - from[2]) * t);
      result.push_back({r, g, b});
    }

    return result;
  }

  /** @brief Converts an vec<int> triplet to an ANSI 256-color code. */
  auto rgb_to_ansi256(vec<int>& rgb) -> int {
    int r = int(rgb[0] * 5 / 255.0f);
    int g = int(rgb[1] * 5 / 255.0f);
    int b = int(rgb[2] * 5 / 255.0f);
    return 16 + 36 * r + 6 * g + b;
  }
};

------------------------------
 FILE:  ShellScreen.hpp
 PATH:  core\shell\ShellScreen.hpp
------------------------------

#pragma once
#include "core/shell/ShellStorage.hpp"


class ShellScreen {  
  public:
  
  /** Initializes the screen and defaults to the main screen (ID 0). */
  ShellScreen(ShellStorage& storage): 
    storage(storage) 
  {
    storage.set("screen.id", 0u);
  }

  /** Switch to a screen by ID. Use "main" or "" for the main screen. */
  void switch_to(uint id) { storage.set("screen.id", id); }

  /** Switch to the main screen (empty ID). */
  void switch_to_main() { switch_to(0); }

  /** Returns the screen ID string. */
  auto get_id() -> uint { return storage.get<uint>("screen.id"); }

  /** Helper: Check if screen matches an exact string (e.g. "p01") */
  auto is(uint id) -> bool { return get_id() == id; }

  /** True if current screen is the main screen. */
  auto is_main() -> bool { return get_id() == 0; }

  // ------ Instance variables ------
  ShellStorage& storage;
};

------------------------------
 FILE:  ShellStorage.hpp
 PATH:  core\shell\ShellStorage.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"


/** A dynamic runtime key-value store for shell commands and internal state. */
class ShellStorage {
  public:

  ShellStorage():
    storage (map<str,any>()) {}

  /** Get a reference to a stored value. Throws if key/type is incorrect. */
  template <typename Type>
  auto get(const str& key) -> Type& {
    try {
      return cast<Type&>(storage.at(key)); 
    }
    catch (const out_of_range&) {
      throw runtime_error(format("ShellStorage: Missing key '{}'", key));
    } 
    catch (const bad_any_cast&) {
      throw runtime_error(format("ShellStorage: Bad type cast for key '{}'", key));
    }
  }

  /** Set a value in shell's dynamic storage. */
  template <typename Type>
  void set(const str& key, Type value) { storage[key] = move(value); }

  /** Check if a key exists in the storage. */
  auto has(const str& key) -> bool { return storage.contains(key); }

  /** Remove a key from storage. */
  void remove(const str& key) { storage.erase(key); }

  // ------ Instance variables ------
  map<str,any> storage;
};

------------------------------
 FILE:  Shell.impl.hpp
 PATH:  core\shell\internal\Shell.impl.hpp
------------------------------

#pragma once
#include "core/common/imports/_all.hpp"
#include "core/common/utility/Ansi.hpp"
#include "core/common/utility/RichText.hpp"
#include "core/command/CommandInterpreter.hpp"
#include "core/scheduler/Scheduler.hpp"

// Shell-specific includes
#include "core/shell/ShellBanner.hpp"
#include "core/shell/ShellStorage.hpp"
#include "core/shell/ShellScreen.hpp"


/** @brief Interactive shell managing CLI, events, and system ticks. */
class Shell {  
  public:

  Shell(): 
    interpreter   (CommandInterpreter::get()),  // Instance of the command interpreter
    shell_thread  (),                           // Shell thread (starts later in start())
    system_thread (),                           // Shell thread (starts later in start())
    shell_active  (atomic_bool{true}),          // Atomic flag to control shell lifecycle
    system_active (atomic_bool{true}),          // Atomic flag to control shell lifecycle
    scheduler     (Scheduler()),                // Owned scheduler instance
    banner        (ShellBanner()),              // For printing the shell banner
    storage       (ShellStorage()),             // Storage for dynamic shell/session data
    screen        (storage) {}                  // Owned instance of shell screen manager

  /** @brief Starts shell and system threads and blocks until shutdown. */
  void start() {
    initialize();

    // Start shell (input) and system (scheduler) threads
    shell_thread  = Thread([&] { 
      cout << RichText("Type [fg=#d39c6a]initialize[/] to start...\n\n");
      while (shell_active)  
        tick_shell(); 
    });

    system_thread = Thread([&] { 
      while (system_active) 
        tick_system(); 
    });

    // Wait until both threads finish (safe from main thread)
    if (shell_thread.joinable())  shell_thread.join();
    if (system_thread.joinable()) system_thread.join();
    system("cls");
  }

  /** @brief Triggers shutdown. Must be called inside shell thread only. */
  void stop(bool silent=false) {
    if (!shell_active && !system_active)
      return;

    if (!silent)
      cout << "[Shell] Shutting down...\n" << flush;

    shell_active = false;
    system_active = false;
    sleep_for(300ms);       // Optional pause for effect
  }

  // ------ Instance variables ------

  CommandInterpreter& interpreter;    
  Thread shell_thread;
  Thread system_thread;
  atomic_bool shell_active;
  atomic_bool system_active;
  Scheduler scheduler; 
  ShellBanner banner;
  ShellStorage storage;
  ShellScreen screen;

  // ------ Internal helpers ------
  private:

  /** @brief Populates the CommandInterpreter with all available commands (See impl in Shell.hpp). */
  void register_commands();

  /** @brief Initializes terminal and registers all event listeners. */
  void initialize() {
    RichText::enable();                 // Prepare terminal settings for output
    register_commands();                // Initialize command handlers
    storage.set("initialized", false);  // Set initialized to false (to be changed by initialize command later)
    
    system("cls");
    cout << '\n';                       // Leave line 1 blank
  }

  /** @brief Executes one shell input cycle. Called repeatedly by shell thread. */
  void tick_shell() {
    cout << ">>> " << flush;
    if (str input; getline(cin, input)) {
      with_locked([&]{
        interpreter.execute(input, *this);  // Executes commands
        cout << '\n';
      });

    } else {
      cout << "[Shell] Input stream closed.\n" << flush;
      stop(true);
    }
  }

  /** @brief Executes one scheduler tick. Called repeatedly by system thread. */
  void tick_system() {
    with_locked([&] {
      scheduler.tick();
    });

    sleep_for(100ms);   // Tick interval
  }
};
